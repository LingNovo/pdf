// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 07 Mar 2018 17:31:54 CST.
// By https://git.io/c-for-go. DO NOT EDIT.

package mupdf

/*
#include "mupdf/pdf.h"
#include "mupdf/fitz.h"
#include <stdlib.h>
#include "cgo_helpers.h"
#cgo LDFLAGS: -lm -lmupdf -lmupdfthird
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *FzAllocContext) Ref() *C.fz_alloc_context {
	if x == nil {
		return nil
	}
	return (*C.fz_alloc_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzAllocContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzAllocContextRef converts the C object reference into a raw struct reference without wrapping.
func NewFzAllocContextRef(ref unsafe.Pointer) *FzAllocContext {
	return (*FzAllocContext)(ref)
}

// NewFzAllocContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzAllocContext() *FzAllocContext {
	return (*FzAllocContext)(allocFzAllocContextMemory(1))
}

// allocFzAllocContextMemory allocates memory for type C.fz_alloc_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzAllocContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzAllocContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzAllocContextValue = unsafe.Sizeof([1]C.fz_alloc_context{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzAllocContext) PassRef() *C.fz_alloc_context {
	if x == nil {
		x = (*FzAllocContext)(allocFzAllocContextMemory(1))
	}
	return (*C.fz_alloc_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzErrorContext) Ref() *C.fz_error_context {
	if x == nil {
		return nil
	}
	return (*C.fz_error_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzErrorContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzErrorContextRef converts the C object reference into a raw struct reference without wrapping.
func NewFzErrorContextRef(ref unsafe.Pointer) *FzErrorContext {
	return (*FzErrorContext)(ref)
}

// NewFzErrorContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzErrorContext() *FzErrorContext {
	return (*FzErrorContext)(allocFzErrorContextMemory(1))
}

// allocFzErrorContextMemory allocates memory for type C.fz_error_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzErrorContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzErrorContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzErrorContextValue = unsafe.Sizeof([1]C.fz_error_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzErrorContext) PassRef() *C.fz_error_context {
	if x == nil {
		x = (*FzErrorContext)(allocFzErrorContextMemory(1))
	}
	return (*C.fz_error_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzErrorStackSlot) Ref() *C.fz_error_stack_slot {
	if x == nil {
		return nil
	}
	return (*C.fz_error_stack_slot)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzErrorStackSlot) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzErrorStackSlotRef converts the C object reference into a raw struct reference without wrapping.
func NewFzErrorStackSlotRef(ref unsafe.Pointer) *FzErrorStackSlot {
	return (*FzErrorStackSlot)(ref)
}

// NewFzErrorStackSlot allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzErrorStackSlot() *FzErrorStackSlot {
	return (*FzErrorStackSlot)(allocFzErrorStackSlotMemory(1))
}

// allocFzErrorStackSlotMemory allocates memory for type C.fz_error_stack_slot in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzErrorStackSlotMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzErrorStackSlotValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzErrorStackSlotValue = unsafe.Sizeof([1]C.fz_error_stack_slot{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzErrorStackSlot) PassRef() *C.fz_error_stack_slot {
	if x == nil {
		x = (*FzErrorStackSlot)(allocFzErrorStackSlotMemory(1))
	}
	return (*C.fz_error_stack_slot)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzIdContext) Ref() *C.fz_id_context {
	if x == nil {
		return nil
	}
	return (*C.fz_id_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzIdContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzIdContextRef converts the C object reference into a raw struct reference without wrapping.
func NewFzIdContextRef(ref unsafe.Pointer) *FzIdContext {
	return (*FzIdContext)(ref)
}

// NewFzIdContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzIdContext() *FzIdContext {
	return (*FzIdContext)(allocFzIdContextMemory(1))
}

// allocFzIdContextMemory allocates memory for type C.fz_id_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzIdContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzIdContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzIdContextValue = unsafe.Sizeof([1]C.fz_id_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzIdContext) PassRef() *C.fz_id_context {
	if x == nil {
		x = (*FzIdContext)(allocFzIdContextMemory(1))
	}
	return (*C.fz_id_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzWarnContext) Ref() *C.fz_warn_context {
	if x == nil {
		return nil
	}
	return (*C.fz_warn_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzWarnContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzWarnContextRef converts the C object reference into a raw struct reference without wrapping.
func NewFzWarnContextRef(ref unsafe.Pointer) *FzWarnContext {
	return (*FzWarnContext)(ref)
}

// NewFzWarnContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzWarnContext() *FzWarnContext {
	return (*FzWarnContext)(allocFzWarnContextMemory(1))
}

// allocFzWarnContextMemory allocates memory for type C.fz_warn_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzWarnContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzWarnContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzWarnContextValue = unsafe.Sizeof([1]C.fz_warn_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzWarnContext) PassRef() *C.fz_warn_context {
	if x == nil {
		x = (*FzWarnContext)(allocFzWarnContextMemory(1))
	}
	return (*C.fz_warn_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzFontContext) Ref() *C.fz_font_context {
	if x == nil {
		return nil
	}
	return (*C.fz_font_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzFontContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzFontContextRef converts the C object reference into a raw struct reference without wrapping.
func NewFzFontContextRef(ref unsafe.Pointer) *FzFontContext {
	return (*FzFontContext)(ref)
}

// NewFzFontContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzFontContext() *FzFontContext {
	return (*FzFontContext)(allocFzFontContextMemory(1))
}

// allocFzFontContextMemory allocates memory for type C.fz_font_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzFontContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzFontContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzFontContextValue = unsafe.Sizeof([1]C.fz_font_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzFontContext) PassRef() *C.fz_font_context {
	if x == nil {
		x = (*FzFontContext)(allocFzFontContextMemory(1))
	}
	return (*C.fz_font_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzColorspaceContext) Ref() *C.fz_colorspace_context {
	if x == nil {
		return nil
	}
	return (*C.fz_colorspace_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzColorspaceContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzColorspaceContextRef converts the C object reference into a raw struct reference without wrapping.
func NewFzColorspaceContextRef(ref unsafe.Pointer) *FzColorspaceContext {
	return (*FzColorspaceContext)(ref)
}

// NewFzColorspaceContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzColorspaceContext() *FzColorspaceContext {
	return (*FzColorspaceContext)(allocFzColorspaceContextMemory(1))
}

// allocFzColorspaceContextMemory allocates memory for type C.fz_colorspace_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzColorspaceContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzColorspaceContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzColorspaceContextValue = unsafe.Sizeof([1]C.fz_colorspace_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzColorspaceContext) PassRef() *C.fz_colorspace_context {
	if x == nil {
		x = (*FzColorspaceContext)(allocFzColorspaceContextMemory(1))
	}
	return (*C.fz_colorspace_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzCmmEngine) Ref() *C.fz_cmm_engine {
	if x == nil {
		return nil
	}
	return (*C.fz_cmm_engine)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzCmmEngine) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzCmmEngineRef converts the C object reference into a raw struct reference without wrapping.
func NewFzCmmEngineRef(ref unsafe.Pointer) *FzCmmEngine {
	return (*FzCmmEngine)(ref)
}

// NewFzCmmEngine allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzCmmEngine() *FzCmmEngine {
	return (*FzCmmEngine)(allocFzCmmEngineMemory(1))
}

// allocFzCmmEngineMemory allocates memory for type C.fz_cmm_engine in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzCmmEngineMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzCmmEngineValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzCmmEngineValue = unsafe.Sizeof([1]C.fz_cmm_engine{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzCmmEngine) PassRef() *C.fz_cmm_engine {
	if x == nil {
		x = (*FzCmmEngine)(allocFzCmmEngineMemory(1))
	}
	return (*C.fz_cmm_engine)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzCmmInstance) Ref() *C.fz_cmm_instance {
	if x == nil {
		return nil
	}
	return (*C.fz_cmm_instance)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzCmmInstance) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzCmmInstanceRef converts the C object reference into a raw struct reference without wrapping.
func NewFzCmmInstanceRef(ref unsafe.Pointer) *FzCmmInstance {
	return (*FzCmmInstance)(ref)
}

// NewFzCmmInstance allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzCmmInstance() *FzCmmInstance {
	return (*FzCmmInstance)(allocFzCmmInstanceMemory(1))
}

// allocFzCmmInstanceMemory allocates memory for type C.fz_cmm_instance in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzCmmInstanceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzCmmInstanceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzCmmInstanceValue = unsafe.Sizeof([1]C.fz_cmm_instance{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzCmmInstance) PassRef() *C.fz_cmm_instance {
	if x == nil {
		x = (*FzCmmInstance)(allocFzCmmInstanceMemory(1))
	}
	return (*C.fz_cmm_instance)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzAaContext) Ref() *C.fz_aa_context {
	if x == nil {
		return nil
	}
	return (*C.fz_aa_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzAaContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzAaContextRef converts the C object reference into a raw struct reference without wrapping.
func NewFzAaContextRef(ref unsafe.Pointer) *FzAaContext {
	return (*FzAaContext)(ref)
}

// NewFzAaContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzAaContext() *FzAaContext {
	return (*FzAaContext)(allocFzAaContextMemory(1))
}

// allocFzAaContextMemory allocates memory for type C.fz_aa_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzAaContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzAaContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzAaContextValue = unsafe.Sizeof([1]C.fz_aa_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzAaContext) PassRef() *C.fz_aa_context {
	if x == nil {
		x = (*FzAaContext)(allocFzAaContextMemory(1))
	}
	return (*C.fz_aa_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzStyleContext) Ref() *C.fz_style_context {
	if x == nil {
		return nil
	}
	return (*C.fz_style_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzStyleContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzStyleContextRef converts the C object reference into a raw struct reference without wrapping.
func NewFzStyleContextRef(ref unsafe.Pointer) *FzStyleContext {
	return (*FzStyleContext)(ref)
}

// NewFzStyleContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzStyleContext() *FzStyleContext {
	return (*FzStyleContext)(allocFzStyleContextMemory(1))
}

// allocFzStyleContextMemory allocates memory for type C.fz_style_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzStyleContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzStyleContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzStyleContextValue = unsafe.Sizeof([1]C.fz_style_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzStyleContext) PassRef() *C.fz_style_context {
	if x == nil {
		x = (*FzStyleContext)(allocFzStyleContextMemory(1))
	}
	return (*C.fz_style_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzLocksContext) Ref() *C.fz_locks_context {
	if x == nil {
		return nil
	}
	return (*C.fz_locks_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzLocksContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzLocksContextRef converts the C object reference into a raw struct reference without wrapping.
func NewFzLocksContextRef(ref unsafe.Pointer) *FzLocksContext {
	return (*FzLocksContext)(ref)
}

// NewFzLocksContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzLocksContext() *FzLocksContext {
	return (*FzLocksContext)(allocFzLocksContextMemory(1))
}

// allocFzLocksContextMemory allocates memory for type C.fz_locks_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzLocksContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzLocksContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzLocksContextValue = unsafe.Sizeof([1]C.fz_locks_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzLocksContext) PassRef() *C.fz_locks_context {
	if x == nil {
		x = (*FzLocksContext)(allocFzLocksContextMemory(1))
	}
	return (*C.fz_locks_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzTuningContext) Ref() *C.fz_tuning_context {
	if x == nil {
		return nil
	}
	return (*C.fz_tuning_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzTuningContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzTuningContextRef converts the C object reference into a raw struct reference without wrapping.
func NewFzTuningContextRef(ref unsafe.Pointer) *FzTuningContext {
	return (*FzTuningContext)(ref)
}

// NewFzTuningContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzTuningContext() *FzTuningContext {
	return (*FzTuningContext)(allocFzTuningContextMemory(1))
}

// allocFzTuningContextMemory allocates memory for type C.fz_tuning_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzTuningContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzTuningContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzTuningContextValue = unsafe.Sizeof([1]C.fz_tuning_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzTuningContext) PassRef() *C.fz_tuning_context {
	if x == nil {
		x = (*FzTuningContext)(allocFzTuningContextMemory(1))
	}
	return (*C.fz_tuning_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzStore) Ref() *C.fz_store {
	if x == nil {
		return nil
	}
	return (*C.fz_store)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzStore) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzStoreRef converts the C object reference into a raw struct reference without wrapping.
func NewFzStoreRef(ref unsafe.Pointer) *FzStore {
	return (*FzStore)(ref)
}

// NewFzStore allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzStore() *FzStore {
	return (*FzStore)(allocFzStoreMemory(1))
}

// allocFzStoreMemory allocates memory for type C.fz_store in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzStoreMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzStoreValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzStoreValue = unsafe.Sizeof([1]C.fz_store{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzStore) PassRef() *C.fz_store {
	if x == nil {
		x = (*FzStore)(allocFzStoreMemory(1))
	}
	return (*C.fz_store)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzGlyphCache) Ref() *C.fz_glyph_cache {
	if x == nil {
		return nil
	}
	return (*C.fz_glyph_cache)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzGlyphCache) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzGlyphCacheRef converts the C object reference into a raw struct reference without wrapping.
func NewFzGlyphCacheRef(ref unsafe.Pointer) *FzGlyphCache {
	return (*FzGlyphCache)(ref)
}

// NewFzGlyphCache allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzGlyphCache() *FzGlyphCache {
	return (*FzGlyphCache)(allocFzGlyphCacheMemory(1))
}

// allocFzGlyphCacheMemory allocates memory for type C.fz_glyph_cache in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzGlyphCacheMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzGlyphCacheValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzGlyphCacheValue = unsafe.Sizeof([1]C.fz_glyph_cache{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzGlyphCache) PassRef() *C.fz_glyph_cache {
	if x == nil {
		x = (*FzGlyphCache)(allocFzGlyphCacheMemory(1))
	}
	return (*C.fz_glyph_cache)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzDocumentHandlerContext) Ref() *C.fz_document_handler_context {
	if x == nil {
		return nil
	}
	return (*C.fz_document_handler_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzDocumentHandlerContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzDocumentHandlerContextRef converts the C object reference into a raw struct reference without wrapping.
func NewFzDocumentHandlerContextRef(ref unsafe.Pointer) *FzDocumentHandlerContext {
	return (*FzDocumentHandlerContext)(ref)
}

// NewFzDocumentHandlerContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzDocumentHandlerContext() *FzDocumentHandlerContext {
	return (*FzDocumentHandlerContext)(allocFzDocumentHandlerContextMemory(1))
}

// allocFzDocumentHandlerContextMemory allocates memory for type C.fz_document_handler_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzDocumentHandlerContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzDocumentHandlerContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzDocumentHandlerContextValue = unsafe.Sizeof([1]C.fz_document_handler_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzDocumentHandlerContext) PassRef() *C.fz_document_handler_context {
	if x == nil {
		x = (*FzDocumentHandlerContext)(allocFzDocumentHandlerContextMemory(1))
	}
	return (*C.fz_document_handler_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzOutputContext) Ref() *C.fz_output_context {
	if x == nil {
		return nil
	}
	return (*C.fz_output_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzOutputContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzOutputContextRef converts the C object reference into a raw struct reference without wrapping.
func NewFzOutputContextRef(ref unsafe.Pointer) *FzOutputContext {
	return (*FzOutputContext)(ref)
}

// NewFzOutputContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzOutputContext() *FzOutputContext {
	return (*FzOutputContext)(allocFzOutputContextMemory(1))
}

// allocFzOutputContextMemory allocates memory for type C.fz_output_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzOutputContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzOutputContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzOutputContextValue = unsafe.Sizeof([1]C.fz_output_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzOutputContext) PassRef() *C.fz_output_context {
	if x == nil {
		x = (*FzOutputContext)(allocFzOutputContextMemory(1))
	}
	return (*C.fz_output_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzContext) Ref() *C.fz_context {
	if x == nil {
		return nil
	}
	return (*C.fz_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzContextRef converts the C object reference into a raw struct reference without wrapping.
func NewFzContextRef(ref unsafe.Pointer) *FzContext {
	return (*FzContext)(ref)
}

// NewFzContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzContext() *FzContext {
	return (*FzContext)(allocFzContextMemory(1))
}

// allocFzContextMemory allocates memory for type C.fz_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzContextValue = unsafe.Sizeof([1]C.fz_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzContext) PassRef() *C.fz_context {
	if x == nil {
		x = (*FzContext)(allocFzContextMemory(1))
	}
	return (*C.fz_context)(unsafe.Pointer(x))
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// packSFzIrect reads sliced Go data structure out from plain C format.
func packSFzIrect(v []FzIrect, ptr0 *C.fz_irect) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFzIrectValue]C.fz_irect)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFzIrectRef(unsafe.Pointer(&ptr1))
	}
}

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

func (x FzTuneImageDecodeFn) PassRef() (ref *C.fz_tune_image_decode_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzTuneImageDecodeFn4232B35AFunc == nil {
		fzTuneImageDecodeFn4232B35AFunc = x
	}
	return (*C.fz_tune_image_decode_fn)(C.fz_tune_image_decode_fn_4232b35a), nil
}

func NewFzTuneImageDecodeFnRef(ref unsafe.Pointer) *FzTuneImageDecodeFn {
	return (*FzTuneImageDecodeFn)(ref)
}

//export fzTuneImageDecodeFn4232B35A
func fzTuneImageDecodeFn4232B35A(carg unsafe.Pointer, cw C.int, ch C.int, cl2factor C.int, csubarea *C.fz_irect) {
	if fzTuneImageDecodeFn4232B35AFunc != nil {
		arg4232b35a := (unsafe.Pointer)(unsafe.Pointer(carg))
		w4232b35a := (int32)(cw)
		h4232b35a := (int32)(ch)
		l2factor4232b35a := (int32)(cl2factor)
		var subarea4232b35a []FzIrect
		packSFzIrect(subarea4232b35a, csubarea)
		fzTuneImageDecodeFn4232B35AFunc(arg4232b35a, w4232b35a, h4232b35a, l2factor4232b35a, subarea4232b35a)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzTuneImageDecodeFn4232B35AFunc FzTuneImageDecodeFn

func (x FzTuneImageScaleFn) PassRef() (ref *C.fz_tune_image_scale_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzTuneImageScaleFn1989219Func == nil {
		fzTuneImageScaleFn1989219Func = x
	}
	return (*C.fz_tune_image_scale_fn)(C.fz_tune_image_scale_fn_1989219), nil
}

func NewFzTuneImageScaleFnRef(ref unsafe.Pointer) *FzTuneImageScaleFn {
	return (*FzTuneImageScaleFn)(ref)
}

//export fzTuneImageScaleFn1989219
func fzTuneImageScaleFn1989219(carg unsafe.Pointer, cdstW C.int, cdstH C.int, csrcW C.int, csrcH C.int) C.int {
	if fzTuneImageScaleFn1989219Func != nil {
		arg1989219 := (unsafe.Pointer)(unsafe.Pointer(carg))
		dstW1989219 := (int32)(cdstW)
		dstH1989219 := (int32)(cdstH)
		srcW1989219 := (int32)(csrcW)
		srcH1989219 := (int32)(csrcH)
		ret1989219 := fzTuneImageScaleFn1989219Func(arg1989219, dstW1989219, dstH1989219, srcW1989219, srcH1989219)
		ret, _ := (C.int)(ret1989219), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzTuneImageScaleFn1989219Func FzTuneImageScaleFn

// Ref returns a reference to C object as it is.
func (x *FzPoint) Ref() *C.fz_point {
	if x == nil {
		return nil
	}
	return (*C.fz_point)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzPoint) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzPointRef converts the C object reference into a raw struct reference without wrapping.
func NewFzPointRef(ref unsafe.Pointer) *FzPoint {
	return (*FzPoint)(ref)
}

// NewFzPoint allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzPoint() *FzPoint {
	return (*FzPoint)(allocFzPointMemory(1))
}

// allocFzPointMemory allocates memory for type C.fz_point in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzPointMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzPointValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzPointValue = unsafe.Sizeof([1]C.fz_point{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzPoint) PassRef() *C.fz_point {
	if x == nil {
		x = (*FzPoint)(allocFzPointMemory(1))
	}
	return (*C.fz_point)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzRect) Ref() *C.fz_rect {
	if x == nil {
		return nil
	}
	return (*C.fz_rect)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzRect) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzRectRef converts the C object reference into a raw struct reference without wrapping.
func NewFzRectRef(ref unsafe.Pointer) *FzRect {
	return (*FzRect)(ref)
}

// NewFzRect allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzRect() *FzRect {
	return (*FzRect)(allocFzRectMemory(1))
}

// allocFzRectMemory allocates memory for type C.fz_rect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzRectValue = unsafe.Sizeof([1]C.fz_rect{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzRect) PassRef() *C.fz_rect {
	if x == nil {
		x = (*FzRect)(allocFzRectMemory(1))
	}
	return (*C.fz_rect)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzIrect) Ref() *C.fz_irect {
	if x == nil {
		return nil
	}
	return (*C.fz_irect)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzIrect) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzIrectRef converts the C object reference into a raw struct reference without wrapping.
func NewFzIrectRef(ref unsafe.Pointer) *FzIrect {
	return (*FzIrect)(ref)
}

// NewFzIrect allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzIrect() *FzIrect {
	return (*FzIrect)(allocFzIrectMemory(1))
}

// allocFzIrectMemory allocates memory for type C.fz_irect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzIrectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzIrectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzIrectValue = unsafe.Sizeof([1]C.fz_irect{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzIrect) PassRef() *C.fz_irect {
	if x == nil {
		x = (*FzIrect)(allocFzIrectMemory(1))
	}
	return (*C.fz_irect)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzMatrix) Ref() *C.fz_matrix {
	if x == nil {
		return nil
	}
	return (*C.fz_matrix)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzMatrix) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzMatrixRef converts the C object reference into a raw struct reference without wrapping.
func NewFzMatrixRef(ref unsafe.Pointer) *FzMatrix {
	return (*FzMatrix)(ref)
}

// NewFzMatrix allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzMatrix() *FzMatrix {
	return (*FzMatrix)(allocFzMatrixMemory(1))
}

// allocFzMatrixMemory allocates memory for type C.fz_matrix in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzMatrixMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzMatrixValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzMatrixValue = unsafe.Sizeof([1]C.fz_matrix{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzMatrix) PassRef() *C.fz_matrix {
	if x == nil {
		x = (*FzMatrix)(allocFzMatrixMemory(1))
	}
	return (*C.fz_matrix)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzMd5) Ref() *C.fz_md5 {
	if x == nil {
		return nil
	}
	return (*C.fz_md5)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzMd5) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzMd5Ref converts the C object reference into a raw struct reference without wrapping.
func NewFzMd5Ref(ref unsafe.Pointer) *FzMd5 {
	return (*FzMd5)(ref)
}

// NewFzMd5 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzMd5() *FzMd5 {
	return (*FzMd5)(allocFzMd5Memory(1))
}

// allocFzMd5Memory allocates memory for type C.fz_md5 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzMd5Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzMd5Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzMd5Value = unsafe.Sizeof([1]C.fz_md5{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzMd5) PassRef() *C.fz_md5 {
	if x == nil {
		x = (*FzMd5)(allocFzMd5Memory(1))
	}
	return (*C.fz_md5)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzSha256) Ref() *C.fz_sha256 {
	if x == nil {
		return nil
	}
	return (*C.fz_sha256)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzSha256) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzSha256Ref converts the C object reference into a raw struct reference without wrapping.
func NewFzSha256Ref(ref unsafe.Pointer) *FzSha256 {
	return (*FzSha256)(ref)
}

// NewFzSha256 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzSha256() *FzSha256 {
	return (*FzSha256)(allocFzSha256Memory(1))
}

// allocFzSha256Memory allocates memory for type C.fz_sha256 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzSha256Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzSha256Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzSha256Value = unsafe.Sizeof([1]C.fz_sha256{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzSha256) PassRef() *C.fz_sha256 {
	if x == nil {
		x = (*FzSha256)(allocFzSha256Memory(1))
	}
	return (*C.fz_sha256)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzSha512) Ref() *C.fz_sha512 {
	if x == nil {
		return nil
	}
	return (*C.fz_sha512)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzSha512) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzSha512Ref converts the C object reference into a raw struct reference without wrapping.
func NewFzSha512Ref(ref unsafe.Pointer) *FzSha512 {
	return (*FzSha512)(ref)
}

// NewFzSha512 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzSha512() *FzSha512 {
	return (*FzSha512)(allocFzSha512Memory(1))
}

// allocFzSha512Memory allocates memory for type C.fz_sha512 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzSha512Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzSha512Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzSha512Value = unsafe.Sizeof([1]C.fz_sha512{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzSha512) PassRef() *C.fz_sha512 {
	if x == nil {
		x = (*FzSha512)(allocFzSha512Memory(1))
	}
	return (*C.fz_sha512)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzSha384) Ref() *C.fz_sha384 {
	if x == nil {
		return nil
	}
	return (*C.fz_sha384)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzSha384) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzSha384Ref converts the C object reference into a raw struct reference without wrapping.
func NewFzSha384Ref(ref unsafe.Pointer) *FzSha384 {
	return (*FzSha384)(ref)
}

// NewFzSha384 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzSha384() *FzSha384 {
	return (*FzSha384)(allocFzSha384Memory(1))
}

// allocFzSha384Memory allocates memory for type C.fz_sha384 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzSha384Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzSha384Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzSha384Value = unsafe.Sizeof([1]C.fz_sha384{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzSha384) PassRef() *C.fz_sha384 {
	if x == nil {
		x = (*FzSha384)(allocFzSha384Memory(1))
	}
	return (*C.fz_sha384)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzArc4) Ref() *C.fz_arc4 {
	if x == nil {
		return nil
	}
	return (*C.fz_arc4)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzArc4) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzArc4Ref converts the C object reference into a raw struct reference without wrapping.
func NewFzArc4Ref(ref unsafe.Pointer) *FzArc4 {
	return (*FzArc4)(ref)
}

// NewFzArc4 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzArc4() *FzArc4 {
	return (*FzArc4)(allocFzArc4Memory(1))
}

// allocFzArc4Memory allocates memory for type C.fz_arc4 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzArc4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzArc4Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzArc4Value = unsafe.Sizeof([1]C.fz_arc4{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzArc4) PassRef() *C.fz_arc4 {
	if x == nil {
		x = (*FzArc4)(allocFzArc4Memory(1))
	}
	return (*C.fz_arc4)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzAes) Ref() *C.fz_aes {
	if x == nil {
		return nil
	}
	return (*C.fz_aes)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzAes) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzAesRef converts the C object reference into a raw struct reference without wrapping.
func NewFzAesRef(ref unsafe.Pointer) *FzAes {
	return (*FzAes)(ref)
}

// NewFzAes allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzAes() *FzAes {
	return (*FzAes)(allocFzAesMemory(1))
}

// allocFzAesMemory allocates memory for type C.fz_aes in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzAesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzAesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzAesValue = unsafe.Sizeof([1]C.fz_aes{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzAes) PassRef() *C.fz_aes {
	if x == nil {
		x = (*FzAes)(allocFzAesMemory(1))
	}
	return (*C.fz_aes)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzHashTable) Ref() *C.fz_hash_table {
	if x == nil {
		return nil
	}
	return (*C.fz_hash_table)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzHashTable) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzHashTableRef converts the C object reference into a raw struct reference without wrapping.
func NewFzHashTableRef(ref unsafe.Pointer) *FzHashTable {
	return (*FzHashTable)(ref)
}

// NewFzHashTable allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzHashTable() *FzHashTable {
	return (*FzHashTable)(allocFzHashTableMemory(1))
}

// allocFzHashTableMemory allocates memory for type C.fz_hash_table in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzHashTableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzHashTableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzHashTableValue = unsafe.Sizeof([1]C.fz_hash_table{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzHashTable) PassRef() *C.fz_hash_table {
	if x == nil {
		x = (*FzHashTable)(allocFzHashTableMemory(1))
	}
	return (*C.fz_hash_table)(unsafe.Pointer(x))
}

func (x FzHashTableDropFn) PassRef() (ref *C.fz_hash_table_drop_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzHashTableDropFn7865AC47Func == nil {
		fzHashTableDropFn7865AC47Func = x
	}
	return (*C.fz_hash_table_drop_fn)(C.fz_hash_table_drop_fn_7865ac47), nil
}

func NewFzHashTableDropFnRef(ref unsafe.Pointer) *FzHashTableDropFn {
	return (*FzHashTableDropFn)(ref)
}

//export fzHashTableDropFn7865AC47
func fzHashTableDropFn7865AC47(cctx *C.fz_context, cval unsafe.Pointer) {
	if fzHashTableDropFn7865AC47Func != nil {
		ctx7865ac47 := NewFzContextRef(unsafe.Pointer(cctx))
		val7865ac47 := (unsafe.Pointer)(unsafe.Pointer(cval))
		fzHashTableDropFn7865AC47Func(ctx7865ac47, val7865ac47)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzHashTableDropFn7865AC47Func FzHashTableDropFn

func (x FzHashTableForEachFn) PassRef() (ref *C.fz_hash_table_for_each_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzHashTableForEachFnAF0D233FFunc == nil {
		fzHashTableForEachFnAF0D233FFunc = x
	}
	return (*C.fz_hash_table_for_each_fn)(C.fz_hash_table_for_each_fn_af0d233f), nil
}

func NewFzHashTableForEachFnRef(ref unsafe.Pointer) *FzHashTableForEachFn {
	return (*FzHashTableForEachFn)(ref)
}

//export fzHashTableForEachFnAF0D233F
func fzHashTableForEachFnAF0D233F(cctx *C.fz_context, cstate unsafe.Pointer, ckey unsafe.Pointer, ckeylen C.int, cval unsafe.Pointer) {
	if fzHashTableForEachFnAF0D233FFunc != nil {
		ctxaf0d233f := NewFzContextRef(unsafe.Pointer(cctx))
		stateaf0d233f := (unsafe.Pointer)(unsafe.Pointer(cstate))
		keyaf0d233f := (unsafe.Pointer)(unsafe.Pointer(ckey))
		keylenaf0d233f := (int32)(ckeylen)
		valaf0d233f := (unsafe.Pointer)(unsafe.Pointer(cval))
		fzHashTableForEachFnAF0D233FFunc(ctxaf0d233f, stateaf0d233f, keyaf0d233f, keylenaf0d233f, valaf0d233f)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzHashTableForEachFnAF0D233FFunc FzHashTableForEachFn

// Ref returns a reference to C object as it is.
func (x *FzOutput) Ref() *C.fz_output {
	if x == nil {
		return nil
	}
	return (*C.fz_output)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzOutput) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzOutputRef converts the C object reference into a raw struct reference without wrapping.
func NewFzOutputRef(ref unsafe.Pointer) *FzOutput {
	return (*FzOutput)(ref)
}

// NewFzOutput allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzOutput() *FzOutput {
	return (*FzOutput)(allocFzOutputMemory(1))
}

// allocFzOutputMemory allocates memory for type C.fz_output in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzOutputMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzOutputValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzOutputValue = unsafe.Sizeof([1]C.fz_output{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzOutput) PassRef() *C.fz_output {
	if x == nil {
		x = (*FzOutput)(allocFzOutputMemory(1))
	}
	return (*C.fz_output)(unsafe.Pointer(x))
}

func (x FzOutputWriteFn) PassRef() (ref *C.fz_output_write_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzOutputWriteFn69B8337CFunc == nil {
		fzOutputWriteFn69B8337CFunc = x
	}
	return (*C.fz_output_write_fn)(C.fz_output_write_fn_69b8337c), nil
}

func NewFzOutputWriteFnRef(ref unsafe.Pointer) *FzOutputWriteFn {
	return (*FzOutputWriteFn)(ref)
}

//export fzOutputWriteFn69B8337C
func fzOutputWriteFn69B8337C(cctx *C.fz_context, cstate unsafe.Pointer, cdata unsafe.Pointer, cn C.size_t) {
	if fzOutputWriteFn69B8337CFunc != nil {
		ctx69b8337c := NewFzContextRef(unsafe.Pointer(cctx))
		state69b8337c := (unsafe.Pointer)(unsafe.Pointer(cstate))
		data69b8337c := (unsafe.Pointer)(unsafe.Pointer(cdata))
		n69b8337c := (uint)(cn)
		fzOutputWriteFn69B8337CFunc(ctx69b8337c, state69b8337c, data69b8337c, n69b8337c)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzOutputWriteFn69B8337CFunc FzOutputWriteFn

func (x FzOutputSeekFn) PassRef() (ref *C.fz_output_seek_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzOutputSeekFnBF2E2BEDFunc == nil {
		fzOutputSeekFnBF2E2BEDFunc = x
	}
	return (*C.fz_output_seek_fn)(C.fz_output_seek_fn_bf2e2bed), nil
}

func NewFzOutputSeekFnRef(ref unsafe.Pointer) *FzOutputSeekFn {
	return (*FzOutputSeekFn)(ref)
}

//export fzOutputSeekFnBF2E2BED
func fzOutputSeekFnBF2E2BED(cctx *C.fz_context, cstate unsafe.Pointer, coffset C.int64_t, cwhence C.int) {
	if fzOutputSeekFnBF2E2BEDFunc != nil {
		ctxbf2e2bed := NewFzContextRef(unsafe.Pointer(cctx))
		statebf2e2bed := (unsafe.Pointer)(unsafe.Pointer(cstate))
		offsetbf2e2bed := (int)(coffset)
		whencebf2e2bed := (int32)(cwhence)
		fzOutputSeekFnBF2E2BEDFunc(ctxbf2e2bed, statebf2e2bed, offsetbf2e2bed, whencebf2e2bed)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzOutputSeekFnBF2E2BEDFunc FzOutputSeekFn

func (x FzOutputTellFn) PassRef() (ref *C.fz_output_tell_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzOutputTellFnEA4E4FABFunc == nil {
		fzOutputTellFnEA4E4FABFunc = x
	}
	return (*C.fz_output_tell_fn)(C.fz_output_tell_fn_ea4e4fab), nil
}

func NewFzOutputTellFnRef(ref unsafe.Pointer) *FzOutputTellFn {
	return (*FzOutputTellFn)(ref)
}

//export fzOutputTellFnEA4E4FAB
func fzOutputTellFnEA4E4FAB(cctx *C.fz_context, cstate unsafe.Pointer) C.int64_t {
	if fzOutputTellFnEA4E4FABFunc != nil {
		ctxea4e4fab := NewFzContextRef(unsafe.Pointer(cctx))
		stateea4e4fab := (unsafe.Pointer)(unsafe.Pointer(cstate))
		retea4e4fab := fzOutputTellFnEA4E4FABFunc(ctxea4e4fab, stateea4e4fab)
		ret, _ := (C.int64_t)(retea4e4fab), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzOutputTellFnEA4E4FABFunc FzOutputTellFn

func (x FzOutputCloseFn) PassRef() (ref *C.fz_output_close_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzOutputCloseFnC2D1D433Func == nil {
		fzOutputCloseFnC2D1D433Func = x
	}
	return (*C.fz_output_close_fn)(C.fz_output_close_fn_c2d1d433), nil
}

func NewFzOutputCloseFnRef(ref unsafe.Pointer) *FzOutputCloseFn {
	return (*FzOutputCloseFn)(ref)
}

//export fzOutputCloseFnC2D1D433
func fzOutputCloseFnC2D1D433(cctx *C.fz_context, cstate unsafe.Pointer) {
	if fzOutputCloseFnC2D1D433Func != nil {
		ctxc2d1d433 := NewFzContextRef(unsafe.Pointer(cctx))
		statec2d1d433 := (unsafe.Pointer)(unsafe.Pointer(cstate))
		fzOutputCloseFnC2D1D433Func(ctxc2d1d433, statec2d1d433)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzOutputCloseFnC2D1D433Func FzOutputCloseFn

func (x FzOutputDropFn) PassRef() (ref *C.fz_output_drop_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzOutputDropFnCE2C73B1Func == nil {
		fzOutputDropFnCE2C73B1Func = x
	}
	return (*C.fz_output_drop_fn)(C.fz_output_drop_fn_ce2c73b1), nil
}

func NewFzOutputDropFnRef(ref unsafe.Pointer) *FzOutputDropFn {
	return (*FzOutputDropFn)(ref)
}

//export fzOutputDropFnCE2C73B1
func fzOutputDropFnCE2C73B1(cctx *C.fz_context, cstate unsafe.Pointer) {
	if fzOutputDropFnCE2C73B1Func != nil {
		ctxce2c73b1 := NewFzContextRef(unsafe.Pointer(cctx))
		statece2c73b1 := (unsafe.Pointer)(unsafe.Pointer(cstate))
		fzOutputDropFnCE2C73B1Func(ctxce2c73b1, statece2c73b1)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzOutputDropFnCE2C73B1Func FzOutputDropFn

// Ref returns a reference to C object as it is.
func (x *FzBuffer) Ref() *C.fz_buffer {
	if x == nil {
		return nil
	}
	return (*C.fz_buffer)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzBuffer) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzBufferRef converts the C object reference into a raw struct reference without wrapping.
func NewFzBufferRef(ref unsafe.Pointer) *FzBuffer {
	return (*FzBuffer)(ref)
}

// NewFzBuffer allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzBuffer() *FzBuffer {
	return (*FzBuffer)(allocFzBufferMemory(1))
}

// allocFzBufferMemory allocates memory for type C.fz_buffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzBufferValue = unsafe.Sizeof([1]C.fz_buffer{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzBuffer) PassRef() *C.fz_buffer {
	if x == nil {
		x = (*FzBuffer)(allocFzBufferMemory(1))
	}
	return (*C.fz_buffer)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzPool) Ref() *C.fz_pool {
	if x == nil {
		return nil
	}
	return (*C.fz_pool)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzPool) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzPoolRef converts the C object reference into a raw struct reference without wrapping.
func NewFzPoolRef(ref unsafe.Pointer) *FzPool {
	return (*FzPool)(ref)
}

// NewFzPool allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzPool() *FzPool {
	return (*FzPool)(allocFzPoolMemory(1))
}

// allocFzPoolMemory allocates memory for type C.fz_pool in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzPoolMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzPoolValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzPoolValue = unsafe.Sizeof([1]C.fz_pool{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzPool) PassRef() *C.fz_pool {
	if x == nil {
		x = (*FzPool)(allocFzPoolMemory(1))
	}
	return (*C.fz_pool)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzTree) Ref() *C.fz_tree {
	if x == nil {
		return nil
	}
	return (*C.fz_tree)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzTree) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzTreeRef converts the C object reference into a raw struct reference without wrapping.
func NewFzTreeRef(ref unsafe.Pointer) *FzTree {
	return (*FzTree)(ref)
}

// NewFzTree allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzTree() *FzTree {
	return (*FzTree)(allocFzTreeMemory(1))
}

// allocFzTreeMemory allocates memory for type C.fz_tree in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzTreeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzTreeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzTreeValue = unsafe.Sizeof([1]C.fz_tree{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzTree) PassRef() *C.fz_tree {
	if x == nil {
		x = (*FzTree)(allocFzTreeMemory(1))
	}
	return (*C.fz_tree)(unsafe.Pointer(x))
}

func (x FzBidiFragmentFn) PassRef() (ref *C.fz_bidi_fragment_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzBidiFragmentFnF6D4B809Func == nil {
		fzBidiFragmentFnF6D4B809Func = x
	}
	return (*C.fz_bidi_fragment_fn)(C.fz_bidi_fragment_fn_f6d4b809), nil
}

func NewFzBidiFragmentFnRef(ref unsafe.Pointer) *FzBidiFragmentFn {
	return (*FzBidiFragmentFn)(ref)
}

//export fzBidiFragmentFnF6D4B809
func fzBidiFragmentFnF6D4B809(cfragment *C.uint32_t, cfragmentlen C.size_t, cbidilevel C.int, cscript C.int, carg unsafe.Pointer) {
	if fzBidiFragmentFnF6D4B809Func != nil {
		fragmentf6d4b809 := (*uint32)(unsafe.Pointer(cfragment))
		fragmentlenf6d4b809 := (uint)(cfragmentlen)
		bidilevelf6d4b809 := (int32)(cbidilevel)
		scriptf6d4b809 := (int32)(cscript)
		argf6d4b809 := (unsafe.Pointer)(unsafe.Pointer(carg))
		fzBidiFragmentFnF6D4B809Func(fragmentf6d4b809, fragmentlenf6d4b809, bidilevelf6d4b809, scriptf6d4b809, argf6d4b809)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzBidiFragmentFnF6D4B809Func FzBidiFragmentFn

// Ref returns a reference to C object as it is.
func (x *FzXml) Ref() *C.fz_xml {
	if x == nil {
		return nil
	}
	return (*C.fz_xml)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzXml) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzXmlRef converts the C object reference into a raw struct reference without wrapping.
func NewFzXmlRef(ref unsafe.Pointer) *FzXml {
	return (*FzXml)(ref)
}

// NewFzXml allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzXml() *FzXml {
	return (*FzXml)(allocFzXmlMemory(1))
}

// allocFzXmlMemory allocates memory for type C.fz_xml in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzXmlMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzXmlValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzXmlValue = unsafe.Sizeof([1]C.fz_xml{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzXml) PassRef() *C.fz_xml {
	if x == nil {
		x = (*FzXml)(allocFzXmlMemory(1))
	}
	return (*C.fz_xml)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzStream) Ref() *C.fz_stream {
	if x == nil {
		return nil
	}
	return (*C.fz_stream)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzStream) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzStreamRef converts the C object reference into a raw struct reference without wrapping.
func NewFzStreamRef(ref unsafe.Pointer) *FzStream {
	return (*FzStream)(ref)
}

// NewFzStream allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzStream() *FzStream {
	return (*FzStream)(allocFzStreamMemory(1))
}

// allocFzStreamMemory allocates memory for type C.fz_stream in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzStreamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzStreamValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzStreamValue = unsafe.Sizeof([1]C.fz_stream{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzStream) PassRef() *C.fz_stream {
	if x == nil {
		x = (*FzStream)(allocFzStreamMemory(1))
	}
	return (*C.fz_stream)(unsafe.Pointer(x))
}

func (x FzStreamNextFn) PassRef() (ref *C.fz_stream_next_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzStreamNextFnA646AE0CFunc == nil {
		fzStreamNextFnA646AE0CFunc = x
	}
	return (*C.fz_stream_next_fn)(C.fz_stream_next_fn_a646ae0c), nil
}

func NewFzStreamNextFnRef(ref unsafe.Pointer) *FzStreamNextFn {
	return (*FzStreamNextFn)(ref)
}

//export fzStreamNextFnA646AE0C
func fzStreamNextFnA646AE0C(cctx *C.fz_context, cstm *C.fz_stream, cmax C.size_t) C.int {
	if fzStreamNextFnA646AE0CFunc != nil {
		ctxa646ae0c := NewFzContextRef(unsafe.Pointer(cctx))
		stma646ae0c := NewFzStreamRef(unsafe.Pointer(cstm))
		maxa646ae0c := (uint)(cmax)
		reta646ae0c := fzStreamNextFnA646AE0CFunc(ctxa646ae0c, stma646ae0c, maxa646ae0c)
		ret, _ := (C.int)(reta646ae0c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzStreamNextFnA646AE0CFunc FzStreamNextFn

func (x FzStreamCloseFn) PassRef() (ref *C.fz_stream_close_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzStreamCloseFnAF835BB4Func == nil {
		fzStreamCloseFnAF835BB4Func = x
	}
	return (*C.fz_stream_close_fn)(C.fz_stream_close_fn_af835bb4), nil
}

func NewFzStreamCloseFnRef(ref unsafe.Pointer) *FzStreamCloseFn {
	return (*FzStreamCloseFn)(ref)
}

//export fzStreamCloseFnAF835BB4
func fzStreamCloseFnAF835BB4(cctx *C.fz_context, cstate unsafe.Pointer) {
	if fzStreamCloseFnAF835BB4Func != nil {
		ctxaf835bb4 := NewFzContextRef(unsafe.Pointer(cctx))
		stateaf835bb4 := (unsafe.Pointer)(unsafe.Pointer(cstate))
		fzStreamCloseFnAF835BB4Func(ctxaf835bb4, stateaf835bb4)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzStreamCloseFnAF835BB4Func FzStreamCloseFn

func (x FzStreamSeekFn) PassRef() (ref *C.fz_stream_seek_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzStreamSeekFn304547F8Func == nil {
		fzStreamSeekFn304547F8Func = x
	}
	return (*C.fz_stream_seek_fn)(C.fz_stream_seek_fn_304547f8), nil
}

func NewFzStreamSeekFnRef(ref unsafe.Pointer) *FzStreamSeekFn {
	return (*FzStreamSeekFn)(ref)
}

//export fzStreamSeekFn304547F8
func fzStreamSeekFn304547F8(cctx *C.fz_context, cstm *C.fz_stream, coffset C.int64_t, cwhence C.int) {
	if fzStreamSeekFn304547F8Func != nil {
		ctx304547f8 := NewFzContextRef(unsafe.Pointer(cctx))
		stm304547f8 := NewFzStreamRef(unsafe.Pointer(cstm))
		offset304547f8 := (int)(coffset)
		whence304547f8 := (int32)(cwhence)
		fzStreamSeekFn304547F8Func(ctx304547f8, stm304547f8, offset304547f8, whence304547f8)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzStreamSeekFn304547F8Func FzStreamSeekFn

func (x FzStreamMetaFn) PassRef() (ref *C.fz_stream_meta_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzStreamMetaFn3599FE3DFunc == nil {
		fzStreamMetaFn3599FE3DFunc = x
	}
	return (*C.fz_stream_meta_fn)(C.fz_stream_meta_fn_3599fe3d), nil
}

func NewFzStreamMetaFnRef(ref unsafe.Pointer) *FzStreamMetaFn {
	return (*FzStreamMetaFn)(ref)
}

//export fzStreamMetaFn3599FE3D
func fzStreamMetaFn3599FE3D(cctx *C.fz_context, cstm *C.fz_stream, ckey C.int, csize C.int, cptr unsafe.Pointer) C.int {
	if fzStreamMetaFn3599FE3DFunc != nil {
		ctx3599fe3d := NewFzContextRef(unsafe.Pointer(cctx))
		stm3599fe3d := NewFzStreamRef(unsafe.Pointer(cstm))
		key3599fe3d := (int32)(ckey)
		size3599fe3d := (int32)(csize)
		ptr3599fe3d := (unsafe.Pointer)(unsafe.Pointer(cptr))
		ret3599fe3d := fzStreamMetaFn3599FE3DFunc(ctx3599fe3d, stm3599fe3d, key3599fe3d, size3599fe3d, ptr3599fe3d)
		ret, _ := (C.int)(ret3599fe3d), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzStreamMetaFn3599FE3DFunc FzStreamMetaFn

// Ref returns a reference to C object as it is.
func (x *FzCompressionParams) Ref() *C.fz_compression_params {
	if x == nil {
		return nil
	}
	return (*C.fz_compression_params)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzCompressionParams) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzCompressionParamsRef converts the C object reference into a raw struct reference without wrapping.
func NewFzCompressionParamsRef(ref unsafe.Pointer) *FzCompressionParams {
	return (*FzCompressionParams)(ref)
}

// NewFzCompressionParams allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzCompressionParams() *FzCompressionParams {
	return (*FzCompressionParams)(allocFzCompressionParamsMemory(1))
}

// allocFzCompressionParamsMemory allocates memory for type C.fz_compression_params in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzCompressionParamsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzCompressionParamsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzCompressionParamsValue = unsafe.Sizeof([1]C.fz_compression_params{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzCompressionParams) PassRef() *C.fz_compression_params {
	if x == nil {
		x = (*FzCompressionParams)(allocFzCompressionParamsMemory(1))
	}
	return (*C.fz_compression_params)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzCompressedBuffer) Ref() *C.fz_compressed_buffer {
	if x == nil {
		return nil
	}
	return (*C.fz_compressed_buffer)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzCompressedBuffer) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzCompressedBufferRef converts the C object reference into a raw struct reference without wrapping.
func NewFzCompressedBufferRef(ref unsafe.Pointer) *FzCompressedBuffer {
	return (*FzCompressedBuffer)(ref)
}

// NewFzCompressedBuffer allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzCompressedBuffer() *FzCompressedBuffer {
	return (*FzCompressedBuffer)(allocFzCompressedBufferMemory(1))
}

// allocFzCompressedBufferMemory allocates memory for type C.fz_compressed_buffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzCompressedBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzCompressedBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzCompressedBufferValue = unsafe.Sizeof([1]C.fz_compressed_buffer{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzCompressedBuffer) PassRef() *C.fz_compressed_buffer {
	if x == nil {
		x = (*FzCompressedBuffer)(allocFzCompressedBufferMemory(1))
	}
	return (*C.fz_compressed_buffer)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzJbig2Globals) Ref() *C.fz_jbig2_globals {
	if x == nil {
		return nil
	}
	return (*C.fz_jbig2_globals)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzJbig2Globals) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzJbig2GlobalsRef converts the C object reference into a raw struct reference without wrapping.
func NewFzJbig2GlobalsRef(ref unsafe.Pointer) *FzJbig2Globals {
	return (*FzJbig2Globals)(ref)
}

// NewFzJbig2Globals allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzJbig2Globals() *FzJbig2Globals {
	return (*FzJbig2Globals)(allocFzJbig2GlobalsMemory(1))
}

// allocFzJbig2GlobalsMemory allocates memory for type C.fz_jbig2_globals in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzJbig2GlobalsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzJbig2GlobalsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzJbig2GlobalsValue = unsafe.Sizeof([1]C.fz_jbig2_globals{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzJbig2Globals) PassRef() *C.fz_jbig2_globals {
	if x == nil {
		x = (*FzJbig2Globals)(allocFzJbig2GlobalsMemory(1))
	}
	return (*C.fz_jbig2_globals)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzStorable) Ref() *C.fz_storable {
	if x == nil {
		return nil
	}
	return (*C.fz_storable)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzStorable) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzStorableRef converts the C object reference into a raw struct reference without wrapping.
func NewFzStorableRef(ref unsafe.Pointer) *FzStorable {
	return (*FzStorable)(ref)
}

// NewFzStorable allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzStorable() *FzStorable {
	return (*FzStorable)(allocFzStorableMemory(1))
}

// allocFzStorableMemory allocates memory for type C.fz_storable in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzStorableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzStorableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzStorableValue = unsafe.Sizeof([1]C.fz_storable{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzStorable) PassRef() *C.fz_storable {
	if x == nil {
		x = (*FzStorable)(allocFzStorableMemory(1))
	}
	return (*C.fz_storable)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzKeyStorable) Ref() *C.fz_key_storable {
	if x == nil {
		return nil
	}
	return (*C.fz_key_storable)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzKeyStorable) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzKeyStorableRef converts the C object reference into a raw struct reference without wrapping.
func NewFzKeyStorableRef(ref unsafe.Pointer) *FzKeyStorable {
	return (*FzKeyStorable)(ref)
}

// NewFzKeyStorable allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzKeyStorable() *FzKeyStorable {
	return (*FzKeyStorable)(allocFzKeyStorableMemory(1))
}

// allocFzKeyStorableMemory allocates memory for type C.fz_key_storable in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzKeyStorableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzKeyStorableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzKeyStorableValue = unsafe.Sizeof([1]C.fz_key_storable{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzKeyStorable) PassRef() *C.fz_key_storable {
	if x == nil {
		x = (*FzKeyStorable)(allocFzKeyStorableMemory(1))
	}
	return (*C.fz_key_storable)(unsafe.Pointer(x))
}

func (x FzStoreDropFn) PassRef() (ref *C.fz_store_drop_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzStoreDropFnAAB4A233Func == nil {
		fzStoreDropFnAAB4A233Func = x
	}
	return (*C.fz_store_drop_fn)(C.fz_store_drop_fn_aab4a233), nil
}

func NewFzStoreDropFnRef(ref unsafe.Pointer) *FzStoreDropFn {
	return (*FzStoreDropFn)(ref)
}

//export fzStoreDropFnAAB4A233
func fzStoreDropFnAAB4A233(carg0 *C.fz_context, carg1 *C.fz_storable) {
	if fzStoreDropFnAAB4A233Func != nil {
		arg0aab4a233 := NewFzContextRef(unsafe.Pointer(carg0))
		arg1aab4a233 := NewFzStorableRef(unsafe.Pointer(carg1))
		fzStoreDropFnAAB4A233Func(arg0aab4a233, arg1aab4a233)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzStoreDropFnAAB4A233Func FzStoreDropFn

// Ref returns a reference to C object as it is.
func (x *FzStoreHash) Ref() *C.fz_store_hash {
	if x == nil {
		return nil
	}
	return (*C.fz_store_hash)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzStoreHash) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzStoreHashRef converts the C object reference into a raw struct reference without wrapping.
func NewFzStoreHashRef(ref unsafe.Pointer) *FzStoreHash {
	return (*FzStoreHash)(ref)
}

// NewFzStoreHash allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzStoreHash() *FzStoreHash {
	return (*FzStoreHash)(allocFzStoreHashMemory(1))
}

// allocFzStoreHashMemory allocates memory for type C.fz_store_hash in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzStoreHashMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzStoreHashValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzStoreHashValue = unsafe.Sizeof([1]C.fz_store_hash{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzStoreHash) PassRef() *C.fz_store_hash {
	if x == nil {
		x = (*FzStoreHash)(allocFzStoreHashMemory(1))
	}
	return (*C.fz_store_hash)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzStoreType) Ref() *C.fz_store_type {
	if x == nil {
		return nil
	}
	return (*C.fz_store_type)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzStoreType) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzStoreTypeRef converts the C object reference into a raw struct reference without wrapping.
func NewFzStoreTypeRef(ref unsafe.Pointer) *FzStoreType {
	return (*FzStoreType)(ref)
}

// NewFzStoreType allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzStoreType() *FzStoreType {
	return (*FzStoreType)(allocFzStoreTypeMemory(1))
}

// allocFzStoreTypeMemory allocates memory for type C.fz_store_type in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzStoreTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzStoreTypeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzStoreTypeValue = unsafe.Sizeof([1]C.fz_store_type{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzStoreType) PassRef() *C.fz_store_type {
	if x == nil {
		x = (*FzStoreType)(allocFzStoreTypeMemory(1))
	}
	return (*C.fz_store_type)(unsafe.Pointer(x))
}

func (x FzStoreFilterFn) PassRef() (ref *C.fz_store_filter_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzStoreFilterFnA0DA2DF9Func == nil {
		fzStoreFilterFnA0DA2DF9Func = x
	}
	return (*C.fz_store_filter_fn)(C.fz_store_filter_fn_a0da2df9), nil
}

func NewFzStoreFilterFnRef(ref unsafe.Pointer) *FzStoreFilterFn {
	return (*FzStoreFilterFn)(ref)
}

//export fzStoreFilterFnA0DA2DF9
func fzStoreFilterFnA0DA2DF9(cctx *C.fz_context, carg unsafe.Pointer, ckey unsafe.Pointer) C.int {
	if fzStoreFilterFnA0DA2DF9Func != nil {
		ctxa0da2df9 := NewFzContextRef(unsafe.Pointer(cctx))
		arga0da2df9 := (unsafe.Pointer)(unsafe.Pointer(carg))
		keya0da2df9 := (unsafe.Pointer)(unsafe.Pointer(ckey))
		reta0da2df9 := fzStoreFilterFnA0DA2DF9Func(ctxa0da2df9, arga0da2df9, keya0da2df9)
		ret, _ := (C.int)(reta0da2df9), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzStoreFilterFnA0DA2DF9Func FzStoreFilterFn

// Ref returns a reference to C object as it is.
func (x *FzArchive) Ref() *C.fz_archive {
	if x == nil {
		return nil
	}
	return (*C.fz_archive)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzArchive) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzArchiveRef converts the C object reference into a raw struct reference without wrapping.
func NewFzArchiveRef(ref unsafe.Pointer) *FzArchive {
	return (*FzArchive)(ref)
}

// NewFzArchive allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzArchive() *FzArchive {
	return (*FzArchive)(allocFzArchiveMemory(1))
}

// allocFzArchiveMemory allocates memory for type C.fz_archive in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzArchiveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzArchiveValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzArchiveValue = unsafe.Sizeof([1]C.fz_archive{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzArchive) PassRef() *C.fz_archive {
	if x == nil {
		x = (*FzArchive)(allocFzArchiveMemory(1))
	}
	return (*C.fz_archive)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzZipWriter) Ref() *C.fz_zip_writer {
	if x == nil {
		return nil
	}
	return (*C.fz_zip_writer)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzZipWriter) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzZipWriterRef converts the C object reference into a raw struct reference without wrapping.
func NewFzZipWriterRef(ref unsafe.Pointer) *FzZipWriter {
	return (*FzZipWriter)(ref)
}

// NewFzZipWriter allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzZipWriter() *FzZipWriter {
	return (*FzZipWriter)(allocFzZipWriterMemory(1))
}

// allocFzZipWriterMemory allocates memory for type C.fz_zip_writer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzZipWriterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzZipWriterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzZipWriterValue = unsafe.Sizeof([1]C.fz_zip_writer{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzZipWriter) PassRef() *C.fz_zip_writer {
	if x == nil {
		x = (*FzZipWriter)(allocFzZipWriterMemory(1))
	}
	return (*C.fz_zip_writer)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzColorParams) Ref() *C.fz_color_params {
	if x == nil {
		return nil
	}
	return (*C.fz_color_params)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzColorParams) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzColorParamsRef converts the C object reference into a raw struct reference without wrapping.
func NewFzColorParamsRef(ref unsafe.Pointer) *FzColorParams {
	return (*FzColorParams)(ref)
}

// NewFzColorParams allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzColorParams() *FzColorParams {
	return (*FzColorParams)(allocFzColorParamsMemory(1))
}

// allocFzColorParamsMemory allocates memory for type C.fz_color_params in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzColorParamsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzColorParamsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzColorParamsValue = unsafe.Sizeof([1]C.fz_color_params{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzColorParams) PassRef() *C.fz_color_params {
	if x == nil {
		x = (*FzColorParams)(allocFzColorParamsMemory(1))
	}
	return (*C.fz_color_params)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzColorspace) Ref() *C.fz_colorspace {
	if x == nil {
		return nil
	}
	return (*C.fz_colorspace)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzColorspace) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzColorspaceRef converts the C object reference into a raw struct reference without wrapping.
func NewFzColorspaceRef(ref unsafe.Pointer) *FzColorspace {
	return (*FzColorspace)(ref)
}

// NewFzColorspace allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzColorspace() *FzColorspace {
	return (*FzColorspace)(allocFzColorspaceMemory(1))
}

// allocFzColorspaceMemory allocates memory for type C.fz_colorspace in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzColorspaceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzColorspaceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzColorspaceValue = unsafe.Sizeof([1]C.fz_colorspace{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzColorspace) PassRef() *C.fz_colorspace {
	if x == nil {
		x = (*FzColorspace)(allocFzColorspaceMemory(1))
	}
	return (*C.fz_colorspace)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzIccprofile) Ref() *C.fz_iccprofile {
	if x == nil {
		return nil
	}
	return (*C.fz_iccprofile)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzIccprofile) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzIccprofileRef converts the C object reference into a raw struct reference without wrapping.
func NewFzIccprofileRef(ref unsafe.Pointer) *FzIccprofile {
	return (*FzIccprofile)(ref)
}

// NewFzIccprofile allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzIccprofile() *FzIccprofile {
	return (*FzIccprofile)(allocFzIccprofileMemory(1))
}

// allocFzIccprofileMemory allocates memory for type C.fz_iccprofile in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzIccprofileMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzIccprofileValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzIccprofileValue = unsafe.Sizeof([1]C.fz_iccprofile{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzIccprofile) PassRef() *C.fz_iccprofile {
	if x == nil {
		x = (*FzIccprofile)(allocFzIccprofileMemory(1))
	}
	return (*C.fz_iccprofile)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzIcclink) Ref() *C.fz_icclink {
	if x == nil {
		return nil
	}
	return (*C.fz_icclink)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzIcclink) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzIcclinkRef converts the C object reference into a raw struct reference without wrapping.
func NewFzIcclinkRef(ref unsafe.Pointer) *FzIcclink {
	return (*FzIcclink)(ref)
}

// NewFzIcclink allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzIcclink() *FzIcclink {
	return (*FzIcclink)(allocFzIcclinkMemory(1))
}

// allocFzIcclinkMemory allocates memory for type C.fz_icclink in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzIcclinkMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzIcclinkValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzIcclinkValue = unsafe.Sizeof([1]C.fz_icclink{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzIcclink) PassRef() *C.fz_icclink {
	if x == nil {
		x = (*FzIcclink)(allocFzIcclinkMemory(1))
	}
	return (*C.fz_icclink)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzDefaultColorspaces) Ref() *C.fz_default_colorspaces {
	if x == nil {
		return nil
	}
	return (*C.fz_default_colorspaces)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzDefaultColorspaces) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzDefaultColorspacesRef converts the C object reference into a raw struct reference without wrapping.
func NewFzDefaultColorspacesRef(ref unsafe.Pointer) *FzDefaultColorspaces {
	return (*FzDefaultColorspaces)(ref)
}

// NewFzDefaultColorspaces allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzDefaultColorspaces() *FzDefaultColorspaces {
	return (*FzDefaultColorspaces)(allocFzDefaultColorspacesMemory(1))
}

// allocFzDefaultColorspacesMemory allocates memory for type C.fz_default_colorspaces in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzDefaultColorspacesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzDefaultColorspacesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzDefaultColorspacesValue = unsafe.Sizeof([1]C.fz_default_colorspaces{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzDefaultColorspaces) PassRef() *C.fz_default_colorspaces {
	if x == nil {
		x = (*FzDefaultColorspaces)(allocFzDefaultColorspacesMemory(1))
	}
	return (*C.fz_default_colorspaces)(unsafe.Pointer(x))
}

func (x FzColorspaceConvertFn) PassRef() (ref *C.fz_colorspace_convert_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzColorspaceConvertFnC5345EE1Func == nil {
		fzColorspaceConvertFnC5345EE1Func = x
	}
	return (*C.fz_colorspace_convert_fn)(C.fz_colorspace_convert_fn_c5345ee1), nil
}

func NewFzColorspaceConvertFnRef(ref unsafe.Pointer) *FzColorspaceConvertFn {
	return (*FzColorspaceConvertFn)(ref)
}

//export fzColorspaceConvertFnC5345EE1
func fzColorspaceConvertFnC5345EE1(cctx *C.fz_context, ccs *C.fz_colorspace, csrc *C.float, cdst *C.float) {
	if fzColorspaceConvertFnC5345EE1Func != nil {
		ctxc5345ee1 := NewFzContextRef(unsafe.Pointer(cctx))
		csc5345ee1 := (*FzColorspace)(unsafe.Pointer(ccs))
		var srcc5345ee1 []float32
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&srcc5345ee1))
		hxfc4425b.Data = uintptr(unsafe.Pointer(csrc))
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?

		var dstc5345ee1 []float32
		hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&dstc5345ee1))
		hxf95e7c8.Data = uintptr(unsafe.Pointer(cdst))
		hxf95e7c8.Cap = 0x7fffffff
		// hxf95e7c8.Len = ?

		fzColorspaceConvertFnC5345EE1Func(ctxc5345ee1, csc5345ee1, srcc5345ee1, dstc5345ee1)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzColorspaceConvertFnC5345EE1Func FzColorspaceConvertFn

func (x FzColorspaceDestructFn) PassRef() (ref *C.fz_colorspace_destruct_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzColorspaceDestructFn779FC731Func == nil {
		fzColorspaceDestructFn779FC731Func = x
	}
	return (*C.fz_colorspace_destruct_fn)(C.fz_colorspace_destruct_fn_779fc731), nil
}

func NewFzColorspaceDestructFnRef(ref unsafe.Pointer) *FzColorspaceDestructFn {
	return (*FzColorspaceDestructFn)(ref)
}

//export fzColorspaceDestructFn779FC731
func fzColorspaceDestructFn779FC731(cctx *C.fz_context, ccs *C.fz_colorspace) {
	if fzColorspaceDestructFn779FC731Func != nil {
		ctx779fc731 := NewFzContextRef(unsafe.Pointer(cctx))
		cs779fc731 := (*FzColorspace)(unsafe.Pointer(ccs))
		fzColorspaceDestructFn779FC731Func(ctx779fc731, cs779fc731)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzColorspaceDestructFn779FC731Func FzColorspaceDestructFn

func (x FzColorspaceBaseFn) PassRef() (ref *C.fz_colorspace_base_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzColorspaceBaseFnEBA67BE4Func == nil {
		fzColorspaceBaseFnEBA67BE4Func = x
	}
	return (*C.fz_colorspace_base_fn)(C.fz_colorspace_base_fn_eba67be4), nil
}

func NewFzColorspaceBaseFnRef(ref unsafe.Pointer) *FzColorspaceBaseFn {
	return (*FzColorspaceBaseFn)(ref)
}

//export fzColorspaceBaseFnEBA67BE4
func fzColorspaceBaseFnEBA67BE4(ccs *C.fz_colorspace) *C.fz_colorspace {
	if fzColorspaceBaseFnEBA67BE4Func != nil {
		cseba67be4 := (*FzColorspace)(unsafe.Pointer(ccs))
		reteba67be4 := fzColorspaceBaseFnEBA67BE4Func(cseba67be4)
		ret, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&reteba67be4)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzColorspaceBaseFnEBA67BE4Func FzColorspaceBaseFn

func (x FzColorspaceClampFn) PassRef() (ref *C.fz_colorspace_clamp_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzColorspaceClampFn17A541B8Func == nil {
		fzColorspaceClampFn17A541B8Func = x
	}
	return (*C.fz_colorspace_clamp_fn)(C.fz_colorspace_clamp_fn_17a541b8), nil
}

func NewFzColorspaceClampFnRef(ref unsafe.Pointer) *FzColorspaceClampFn {
	return (*FzColorspaceClampFn)(ref)
}

//export fzColorspaceClampFn17A541B8
func fzColorspaceClampFn17A541B8(ccs *C.fz_colorspace, csrc *C.float, cdst *C.float) {
	if fzColorspaceClampFn17A541B8Func != nil {
		cs17a541b8 := (*FzColorspace)(unsafe.Pointer(ccs))
		src17a541b8 := (*float32)(unsafe.Pointer(csrc))
		var dst17a541b8 []float32
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&dst17a541b8))
		hxff2234b.Data = uintptr(unsafe.Pointer(cdst))
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?

		fzColorspaceClampFn17A541B8Func(cs17a541b8, src17a541b8, dst17a541b8)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzColorspaceClampFn17A541B8Func FzColorspaceClampFn

// Ref returns a reference to C object as it is.
func (x *FzColorConverter) Ref() *C.fz_color_converter {
	if x == nil {
		return nil
	}
	return (*C.fz_color_converter)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzColorConverter) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzColorConverterRef converts the C object reference into a raw struct reference without wrapping.
func NewFzColorConverterRef(ref unsafe.Pointer) *FzColorConverter {
	return (*FzColorConverter)(ref)
}

// NewFzColorConverter allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzColorConverter() *FzColorConverter {
	return (*FzColorConverter)(allocFzColorConverterMemory(1))
}

// allocFzColorConverterMemory allocates memory for type C.fz_color_converter in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzColorConverterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzColorConverterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzColorConverterValue = unsafe.Sizeof([1]C.fz_color_converter{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzColorConverter) PassRef() *C.fz_color_converter {
	if x == nil {
		x = (*FzColorConverter)(allocFzColorConverterMemory(1))
	}
	return (*C.fz_color_converter)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzCalColorspace) Ref() *C.fz_cal_colorspace {
	if x == nil {
		return nil
	}
	return (*C.fz_cal_colorspace)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzCalColorspace) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzCalColorspaceRef converts the C object reference into a raw struct reference without wrapping.
func NewFzCalColorspaceRef(ref unsafe.Pointer) *FzCalColorspace {
	return (*FzCalColorspace)(ref)
}

// NewFzCalColorspace allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzCalColorspace() *FzCalColorspace {
	return (*FzCalColorspace)(allocFzCalColorspaceMemory(1))
}

// allocFzCalColorspaceMemory allocates memory for type C.fz_cal_colorspace in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzCalColorspaceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzCalColorspaceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzCalColorspaceValue = unsafe.Sizeof([1]C.fz_cal_colorspace{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzCalColorspace) PassRef() *C.fz_cal_colorspace {
	if x == nil {
		x = (*FzCalColorspace)(allocFzCalColorspaceMemory(1))
	}
	return (*C.fz_cal_colorspace)(unsafe.Pointer(x))
}

// allocFzPixmapMemory allocates memory for type C.fz_pixmap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzPixmapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzPixmapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzPixmapValue = unsafe.Sizeof([1]C.fz_pixmap{})

// unpackSFzPixmap transforms a sliced Go data structure into plain C format.
func unpackSFzPixmap(x []FzPixmap) (unpacked *C.fz_pixmap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_pixmap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFzPixmapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_pixmap)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_pixmap)(unsafe.Pointer(h.Data))
	return
}

// packSFzPixmap reads sliced Go data structure out from plain C format.
func packSFzPixmap(v []FzPixmap, ptr0 *C.fz_pixmap) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFzPixmapValue]C.fz_pixmap)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFzPixmapRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FzPixmap) Ref() *C.fz_pixmap {
	if x == nil {
		return nil
	}
	return x.ref7c1a1ba1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FzPixmap) Free() {
	if x != nil && x.allocs7c1a1ba1 != nil {
		x.allocs7c1a1ba1.(*cgoAllocMap).Free()
		x.ref7c1a1ba1 = nil
	}
}

// NewFzPixmapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFzPixmapRef(ref unsafe.Pointer) *FzPixmap {
	if ref == nil {
		return nil
	}
	obj := new(FzPixmap)
	obj.ref7c1a1ba1 = (*C.fz_pixmap)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FzPixmap) PassRef() (*C.fz_pixmap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7c1a1ba1 != nil {
		return x.ref7c1a1ba1, nil
	}
	mem7c1a1ba1 := allocFzPixmapMemory(1)
	ref7c1a1ba1 := (*C.fz_pixmap)(mem7c1a1ba1)
	allocs7c1a1ba1 := new(cgoAllocMap)
	allocs7c1a1ba1.Add(mem7c1a1ba1)

	var cstorable_allocs *cgoAllocMap
	ref7c1a1ba1.storable, cstorable_allocs = *(*C.fz_storable)(unsafe.Pointer(&x.Storable)), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cstorable_allocs)

	var cx_allocs *cgoAllocMap
	ref7c1a1ba1.x, cx_allocs = (C.int)(x.X), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref7c1a1ba1.y, cy_allocs = (C.int)(x.Y), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	ref7c1a1ba1.w, cw_allocs = (C.int)(x.W), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref7c1a1ba1.h, ch_allocs = (C.int)(x.H), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(ch_allocs)

	var cn_allocs *cgoAllocMap
	ref7c1a1ba1.n, cn_allocs = (C.uchar)(x.N), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cn_allocs)

	var cs_allocs *cgoAllocMap
	ref7c1a1ba1.s, cs_allocs = (C.uchar)(x.S), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cs_allocs)

	var calpha_allocs *cgoAllocMap
	ref7c1a1ba1.alpha, calpha_allocs = (C.uchar)(x.Alpha), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(calpha_allocs)

	var cflags_allocs *cgoAllocMap
	ref7c1a1ba1.flags, cflags_allocs = (C.uchar)(x.Flags), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cflags_allocs)

	var cstride_allocs *cgoAllocMap
	ref7c1a1ba1.stride, cstride_allocs = (C.ptrdiff_t)(x.Stride), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cstride_allocs)

	var cseps_allocs *cgoAllocMap
	ref7c1a1ba1.seps, cseps_allocs = *(**C.fz_separations)(unsafe.Pointer(&x.Seps)), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cseps_allocs)

	var cxres_allocs *cgoAllocMap
	ref7c1a1ba1.xres, cxres_allocs = (C.int)(x.Xres), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cxres_allocs)

	var cyres_allocs *cgoAllocMap
	ref7c1a1ba1.yres, cyres_allocs = (C.int)(x.Yres), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cyres_allocs)

	var ccolorspace_allocs *cgoAllocMap
	ref7c1a1ba1.colorspace, ccolorspace_allocs = *(**C.fz_colorspace)(unsafe.Pointer(&x.Colorspace)), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(ccolorspace_allocs)

	var csamples_allocs *cgoAllocMap
	ref7c1a1ba1.samples, csamples_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Samples)).Data)), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(csamples_allocs)

	var cunderlying_allocs *cgoAllocMap
	ref7c1a1ba1.underlying, cunderlying_allocs = unpackSFzPixmap(x.Underlying)
	allocs7c1a1ba1.Borrow(cunderlying_allocs)

	x.ref7c1a1ba1 = ref7c1a1ba1
	x.allocs7c1a1ba1 = allocs7c1a1ba1
	return ref7c1a1ba1, allocs7c1a1ba1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FzPixmap) PassValue() (C.fz_pixmap, *cgoAllocMap) {
	if x.ref7c1a1ba1 != nil {
		return *x.ref7c1a1ba1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FzPixmap) Deref() {
	if x.ref7c1a1ba1 == nil {
		return
	}
	x.Storable = *(*FzStorable)(unsafe.Pointer(&x.ref7c1a1ba1.storable))
	x.X = (int32)(x.ref7c1a1ba1.x)
	x.Y = (int32)(x.ref7c1a1ba1.y)
	x.W = (int32)(x.ref7c1a1ba1.w)
	x.H = (int32)(x.ref7c1a1ba1.h)
	x.N = (byte)(x.ref7c1a1ba1.n)
	x.S = (byte)(x.ref7c1a1ba1.s)
	x.Alpha = (byte)(x.ref7c1a1ba1.alpha)
	x.Flags = (byte)(x.ref7c1a1ba1.flags)
	x.Stride = (int)(x.ref7c1a1ba1.stride)
	x.Seps = (*FzSeparations)(unsafe.Pointer(x.ref7c1a1ba1.seps))
	x.Xres = (int32)(x.ref7c1a1ba1.xres)
	x.Yres = (int32)(x.ref7c1a1ba1.yres)
	x.Colorspace = (*FzColorspace)(unsafe.Pointer(x.ref7c1a1ba1.colorspace))
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.Samples))
	hxff73280.Data = uintptr(unsafe.Pointer(x.ref7c1a1ba1.samples))
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	packSFzPixmap(x.Underlying, x.ref7c1a1ba1.underlying)
}

// Ref returns a reference to C object as it is.
func (x *FzOverprint) Ref() *C.fz_overprint {
	if x == nil {
		return nil
	}
	return (*C.fz_overprint)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzOverprint) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzOverprintRef converts the C object reference into a raw struct reference without wrapping.
func NewFzOverprintRef(ref unsafe.Pointer) *FzOverprint {
	return (*FzOverprint)(ref)
}

// NewFzOverprint allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzOverprint() *FzOverprint {
	return (*FzOverprint)(allocFzOverprintMemory(1))
}

// allocFzOverprintMemory allocates memory for type C.fz_overprint in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzOverprintMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzOverprintValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzOverprintValue = unsafe.Sizeof([1]C.fz_overprint{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzOverprint) PassRef() *C.fz_overprint {
	if x == nil {
		x = (*FzOverprint)(allocFzOverprintMemory(1))
	}
	return (*C.fz_overprint)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzScaleCache) Ref() *C.fz_scale_cache {
	if x == nil {
		return nil
	}
	return (*C.fz_scale_cache)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzScaleCache) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzScaleCacheRef converts the C object reference into a raw struct reference without wrapping.
func NewFzScaleCacheRef(ref unsafe.Pointer) *FzScaleCache {
	return (*FzScaleCache)(ref)
}

// NewFzScaleCache allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzScaleCache() *FzScaleCache {
	return (*FzScaleCache)(allocFzScaleCacheMemory(1))
}

// allocFzScaleCacheMemory allocates memory for type C.fz_scale_cache in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzScaleCacheMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzScaleCacheValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzScaleCacheValue = unsafe.Sizeof([1]C.fz_scale_cache{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzScaleCache) PassRef() *C.fz_scale_cache {
	if x == nil {
		x = (*FzScaleCache)(allocFzScaleCacheMemory(1))
	}
	return (*C.fz_scale_cache)(unsafe.Pointer(x))
}

// packSFzColorParams reads sliced Go data structure out from plain C format.
func packSFzColorParams(v []FzColorParams, ptr0 *C.fz_color_params) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFzColorParamsValue]C.fz_color_params)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFzColorParamsRef(unsafe.Pointer(&ptr1))
	}
}

func (x FzPixmapConverter) PassRef() (ref *C.fz_pixmap_converter, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzPixmapConverterA63960AFunc == nil {
		fzPixmapConverterA63960AFunc = x
	}
	return (*C.fz_pixmap_converter)(C.fz_pixmap_converter_a63960a), nil
}

func NewFzPixmapConverterRef(ref unsafe.Pointer) *FzPixmapConverter {
	return (*FzPixmapConverter)(ref)
}

//export fzPixmapConverterA63960A
func fzPixmapConverterA63960A(cctx *C.fz_context, cdp *C.fz_pixmap, csp *C.fz_pixmap, cprf *C.fz_colorspace, cdefaultCs *C.fz_default_colorspaces, ccolorParams *C.fz_color_params, ccopySpots C.int) {
	if fzPixmapConverterA63960AFunc != nil {
		ctxa63960a := NewFzContextRef(unsafe.Pointer(cctx))
		dpa63960a := NewFzPixmapRef(unsafe.Pointer(cdp))
		var spa63960a []FzPixmap
		packSFzPixmap(spa63960a, csp)
		var prfa63960a []FzColorspace
		hxfa9955c := (*sliceHeader)(unsafe.Pointer(&prfa63960a))
		hxfa9955c.Data = uintptr(unsafe.Pointer(cprf))
		hxfa9955c.Cap = 0x7fffffff
		// hxfa9955c.Len = ?

		var defaultCsa63960a []FzDefaultColorspaces
		hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&defaultCsa63960a))
		hxfa3f05c.Data = uintptr(unsafe.Pointer(cdefaultCs))
		hxfa3f05c.Cap = 0x7fffffff
		// hxfa3f05c.Len = ?

		var colorParamsa63960a []FzColorParams
		packSFzColorParams(colorParamsa63960a, ccolorParams)
		copySpotsa63960a := (int32)(ccopySpots)
		fzPixmapConverterA63960AFunc(ctxa63960a, dpa63960a, spa63960a, prfa63960a, defaultCsa63960a, colorParamsa63960a, copySpotsa63960a)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzPixmapConverterA63960AFunc FzPixmapConverter

// Ref returns a reference to C object as it is.
func (x *FzSeparations) Ref() *C.fz_separations {
	if x == nil {
		return nil
	}
	return (*C.fz_separations)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzSeparations) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzSeparationsRef converts the C object reference into a raw struct reference without wrapping.
func NewFzSeparationsRef(ref unsafe.Pointer) *FzSeparations {
	return (*FzSeparations)(ref)
}

// NewFzSeparations allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzSeparations() *FzSeparations {
	return (*FzSeparations)(allocFzSeparationsMemory(1))
}

// allocFzSeparationsMemory allocates memory for type C.fz_separations in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzSeparationsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzSeparationsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzSeparationsValue = unsafe.Sizeof([1]C.fz_separations{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzSeparations) PassRef() *C.fz_separations {
	if x == nil {
		x = (*FzSeparations)(allocFzSeparationsMemory(1))
	}
	return (*C.fz_separations)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzGlyph) Ref() *C.fz_glyph {
	if x == nil {
		return nil
	}
	return (*C.fz_glyph)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzGlyph) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzGlyphRef converts the C object reference into a raw struct reference without wrapping.
func NewFzGlyphRef(ref unsafe.Pointer) *FzGlyph {
	return (*FzGlyph)(ref)
}

// NewFzGlyph allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzGlyph() *FzGlyph {
	return (*FzGlyph)(allocFzGlyphMemory(1))
}

// allocFzGlyphMemory allocates memory for type C.fz_glyph in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzGlyphMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzGlyphValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzGlyphValue = unsafe.Sizeof([1]C.fz_glyph{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzGlyph) PassRef() *C.fz_glyph {
	if x == nil {
		x = (*FzGlyph)(allocFzGlyphMemory(1))
	}
	return (*C.fz_glyph)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzBitmap) Ref() *C.fz_bitmap {
	if x == nil {
		return nil
	}
	return (*C.fz_bitmap)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzBitmap) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzBitmapRef converts the C object reference into a raw struct reference without wrapping.
func NewFzBitmapRef(ref unsafe.Pointer) *FzBitmap {
	return (*FzBitmap)(ref)
}

// NewFzBitmap allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzBitmap() *FzBitmap {
	return (*FzBitmap)(allocFzBitmapMemory(1))
}

// allocFzBitmapMemory allocates memory for type C.fz_bitmap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzBitmapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzBitmapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzBitmapValue = unsafe.Sizeof([1]C.fz_bitmap{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzBitmap) PassRef() *C.fz_bitmap {
	if x == nil {
		x = (*FzBitmap)(allocFzBitmapMemory(1))
	}
	return (*C.fz_bitmap)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzHalftone) Ref() *C.fz_halftone {
	if x == nil {
		return nil
	}
	return (*C.fz_halftone)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzHalftone) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzHalftoneRef converts the C object reference into a raw struct reference without wrapping.
func NewFzHalftoneRef(ref unsafe.Pointer) *FzHalftone {
	return (*FzHalftone)(ref)
}

// NewFzHalftone allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzHalftone() *FzHalftone {
	return (*FzHalftone)(allocFzHalftoneMemory(1))
}

// allocFzHalftoneMemory allocates memory for type C.fz_halftone in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzHalftoneMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzHalftoneValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzHalftoneValue = unsafe.Sizeof([1]C.fz_halftone{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzHalftone) PassRef() *C.fz_halftone {
	if x == nil {
		x = (*FzHalftone)(allocFzHalftoneMemory(1))
	}
	return (*C.fz_halftone)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzImage) Ref() *C.fz_image {
	if x == nil {
		return nil
	}
	return (*C.fz_image)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzImage) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzImageRef converts the C object reference into a raw struct reference without wrapping.
func NewFzImageRef(ref unsafe.Pointer) *FzImage {
	return (*FzImage)(ref)
}

// NewFzImage allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzImage() *FzImage {
	return (*FzImage)(allocFzImageMemory(1))
}

// allocFzImageMemory allocates memory for type C.fz_image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzImageValue = unsafe.Sizeof([1]C.fz_image{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzImage) PassRef() *C.fz_image {
	if x == nil {
		x = (*FzImage)(allocFzImageMemory(1))
	}
	return (*C.fz_image)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzCompressedImage) Ref() *C.fz_compressed_image {
	if x == nil {
		return nil
	}
	return (*C.fz_compressed_image)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzCompressedImage) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzCompressedImageRef converts the C object reference into a raw struct reference without wrapping.
func NewFzCompressedImageRef(ref unsafe.Pointer) *FzCompressedImage {
	return (*FzCompressedImage)(ref)
}

// NewFzCompressedImage allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzCompressedImage() *FzCompressedImage {
	return (*FzCompressedImage)(allocFzCompressedImageMemory(1))
}

// allocFzCompressedImageMemory allocates memory for type C.fz_compressed_image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzCompressedImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzCompressedImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzCompressedImageValue = unsafe.Sizeof([1]C.fz_compressed_image{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzCompressedImage) PassRef() *C.fz_compressed_image {
	if x == nil {
		x = (*FzCompressedImage)(allocFzCompressedImageMemory(1))
	}
	return (*C.fz_compressed_image)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzPixmapImage) Ref() *C.fz_pixmap_image {
	if x == nil {
		return nil
	}
	return (*C.fz_pixmap_image)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzPixmapImage) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzPixmapImageRef converts the C object reference into a raw struct reference without wrapping.
func NewFzPixmapImageRef(ref unsafe.Pointer) *FzPixmapImage {
	return (*FzPixmapImage)(ref)
}

// NewFzPixmapImage allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzPixmapImage() *FzPixmapImage {
	return (*FzPixmapImage)(allocFzPixmapImageMemory(1))
}

// allocFzPixmapImageMemory allocates memory for type C.fz_pixmap_image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzPixmapImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzPixmapImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzPixmapImageValue = unsafe.Sizeof([1]C.fz_pixmap_image{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzPixmapImage) PassRef() *C.fz_pixmap_image {
	if x == nil {
		x = (*FzPixmapImage)(allocFzPixmapImageMemory(1))
	}
	return (*C.fz_pixmap_image)(unsafe.Pointer(x))
}

func (x FzDropImageFn) PassRef() (ref *C.fz_drop_image_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDropImageFn37D8BE50Func == nil {
		fzDropImageFn37D8BE50Func = x
	}
	return (*C.fz_drop_image_fn)(C.fz_drop_image_fn_37d8be50), nil
}

func NewFzDropImageFnRef(ref unsafe.Pointer) *FzDropImageFn {
	return (*FzDropImageFn)(ref)
}

//export fzDropImageFn37D8BE50
func fzDropImageFn37D8BE50(cctx *C.fz_context, cimage *C.fz_image) {
	if fzDropImageFn37D8BE50Func != nil {
		ctx37d8be50 := NewFzContextRef(unsafe.Pointer(cctx))
		image37d8be50 := NewFzImageRef(unsafe.Pointer(cimage))
		fzDropImageFn37D8BE50Func(ctx37d8be50, image37d8be50)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzDropImageFn37D8BE50Func FzDropImageFn

func (x FzImageGetPixmapFn) PassRef() (ref *C.fz_image_get_pixmap_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzImageGetPixmapFnE97EE8EBFunc == nil {
		fzImageGetPixmapFnE97EE8EBFunc = x
	}
	return (*C.fz_image_get_pixmap_fn)(C.fz_image_get_pixmap_fn_e97ee8eb), nil
}

func NewFzImageGetPixmapFnRef(ref unsafe.Pointer) *FzImageGetPixmapFn {
	return (*FzImageGetPixmapFn)(ref)
}

//export fzImageGetPixmapFnE97EE8EB
func fzImageGetPixmapFnE97EE8EB(cctx *C.fz_context, cim *C.fz_image, csubarea *C.fz_irect, cw C.int, ch C.int, cl2factor *C.int) *C.fz_pixmap {
	if fzImageGetPixmapFnE97EE8EBFunc != nil {
		ctxe97ee8eb := NewFzContextRef(unsafe.Pointer(cctx))
		ime97ee8eb := NewFzImageRef(unsafe.Pointer(cim))
		var subareae97ee8eb []FzIrect
		packSFzIrect(subareae97ee8eb, csubarea)
		we97ee8eb := (int32)(cw)
		he97ee8eb := (int32)(ch)
		var l2factore97ee8eb []int32
		hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&l2factore97ee8eb))
		hxf0d18b7.Data = uintptr(unsafe.Pointer(cl2factor))
		hxf0d18b7.Cap = 0x7fffffff
		// hxf0d18b7.Len = ?

		rete97ee8eb := fzImageGetPixmapFnE97EE8EBFunc(ctxe97ee8eb, ime97ee8eb, subareae97ee8eb, we97ee8eb, he97ee8eb, l2factore97ee8eb)
		ret, _ := (*C.fz_pixmap)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&rete97ee8eb)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzImageGetPixmapFnE97EE8EBFunc FzImageGetPixmapFn

func (x FzImageGetSizeFn) PassRef() (ref *C.fz_image_get_size_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzImageGetSizeFn7202727CFunc == nil {
		fzImageGetSizeFn7202727CFunc = x
	}
	return (*C.fz_image_get_size_fn)(C.fz_image_get_size_fn_7202727c), nil
}

func NewFzImageGetSizeFnRef(ref unsafe.Pointer) *FzImageGetSizeFn {
	return (*FzImageGetSizeFn)(ref)
}

//export fzImageGetSizeFn7202727C
func fzImageGetSizeFn7202727C(carg0 *C.fz_context, carg1 *C.fz_image) C.size_t {
	if fzImageGetSizeFn7202727CFunc != nil {
		arg07202727c := NewFzContextRef(unsafe.Pointer(carg0))
		arg17202727c := NewFzImageRef(unsafe.Pointer(carg1))
		ret7202727c := fzImageGetSizeFn7202727CFunc(arg07202727c, arg17202727c)
		ret, _ := (C.size_t)(ret7202727c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzImageGetSizeFn7202727CFunc FzImageGetSizeFn

// Ref returns a reference to C object as it is.
func (x *FzShade) Ref() *C.fz_shade {
	if x == nil {
		return nil
	}
	return (*C.fz_shade)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzShade) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzShadeRef converts the C object reference into a raw struct reference without wrapping.
func NewFzShadeRef(ref unsafe.Pointer) *FzShade {
	return (*FzShade)(ref)
}

// NewFzShade allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzShade() *FzShade {
	return (*FzShade)(allocFzShadeMemory(1))
}

// allocFzShadeMemory allocates memory for type C.fz_shade in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzShadeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzShadeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzShadeValue = unsafe.Sizeof([1]C.fz_shade{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzShade) PassRef() *C.fz_shade {
	if x == nil {
		x = (*FzShade)(allocFzShadeMemory(1))
	}
	return (*C.fz_shade)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzVertex) Ref() *C.fz_vertex {
	if x == nil {
		return nil
	}
	return (*C.fz_vertex)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzVertex) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzVertexRef converts the C object reference into a raw struct reference without wrapping.
func NewFzVertexRef(ref unsafe.Pointer) *FzVertex {
	return (*FzVertex)(ref)
}

// NewFzVertex allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzVertex() *FzVertex {
	return (*FzVertex)(allocFzVertexMemory(1))
}

// allocFzVertexMemory allocates memory for type C.fz_vertex in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzVertexMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzVertexValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzVertexValue = unsafe.Sizeof([1]C.fz_vertex{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzVertex) PassRef() *C.fz_vertex {
	if x == nil {
		x = (*FzVertex)(allocFzVertexMemory(1))
	}
	return (*C.fz_vertex)(unsafe.Pointer(x))
}

// packSFzVertex reads sliced Go data structure out from plain C format.
func packSFzVertex(v []FzVertex, ptr0 *C.fz_vertex) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFzVertexValue]C.fz_vertex)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFzVertexRef(unsafe.Pointer(&ptr1))
	}
}

func (x FzShadePrepareFn) PassRef() (ref *C.fz_shade_prepare_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzShadePrepareFn6A663594Func == nil {
		fzShadePrepareFn6A663594Func = x
	}
	return (*C.fz_shade_prepare_fn)(C.fz_shade_prepare_fn_6a663594), nil
}

func NewFzShadePrepareFnRef(ref unsafe.Pointer) *FzShadePrepareFn {
	return (*FzShadePrepareFn)(ref)
}

//export fzShadePrepareFn6A663594
func fzShadePrepareFn6A663594(cctx *C.fz_context, carg unsafe.Pointer, cv *C.fz_vertex, cc *C.float) {
	if fzShadePrepareFn6A663594Func != nil {
		ctx6a663594 := NewFzContextRef(unsafe.Pointer(cctx))
		arg6a663594 := (unsafe.Pointer)(unsafe.Pointer(carg))
		var v6a663594 []FzVertex
		packSFzVertex(v6a663594, cv)
		var c6a663594 []float32
		hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&c6a663594))
		hxf2fab0d.Data = uintptr(unsafe.Pointer(cc))
		hxf2fab0d.Cap = 0x7fffffff
		// hxf2fab0d.Len = ?

		fzShadePrepareFn6A663594Func(ctx6a663594, arg6a663594, v6a663594, c6a663594)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzShadePrepareFn6A663594Func FzShadePrepareFn

func (x FzShadeProcessFn) PassRef() (ref *C.fz_shade_process_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzShadeProcessFn7E13CCEAFunc == nil {
		fzShadeProcessFn7E13CCEAFunc = x
	}
	return (*C.fz_shade_process_fn)(C.fz_shade_process_fn_7e13ccea), nil
}

func NewFzShadeProcessFnRef(ref unsafe.Pointer) *FzShadeProcessFn {
	return (*FzShadeProcessFn)(ref)
}

//export fzShadeProcessFn7E13CCEA
func fzShadeProcessFn7E13CCEA(cctx *C.fz_context, carg unsafe.Pointer, cav *C.fz_vertex, cbv *C.fz_vertex, ccv *C.fz_vertex) {
	if fzShadeProcessFn7E13CCEAFunc != nil {
		ctx7e13ccea := NewFzContextRef(unsafe.Pointer(cctx))
		arg7e13ccea := (unsafe.Pointer)(unsafe.Pointer(carg))
		var av7e13ccea []FzVertex
		packSFzVertex(av7e13ccea, cav)
		var bv7e13ccea []FzVertex
		packSFzVertex(bv7e13ccea, cbv)
		var cv7e13ccea []FzVertex
		packSFzVertex(cv7e13ccea, ccv)
		fzShadeProcessFn7E13CCEAFunc(ctx7e13ccea, arg7e13ccea, av7e13ccea, bv7e13ccea, cv7e13ccea)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzShadeProcessFn7E13CCEAFunc FzShadeProcessFn

// Ref returns a reference to C object as it is.
func (x *FzFont) Ref() *C.fz_font {
	if x == nil {
		return nil
	}
	return (*C.fz_font)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzFont) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzFontRef converts the C object reference into a raw struct reference without wrapping.
func NewFzFontRef(ref unsafe.Pointer) *FzFont {
	return (*FzFont)(ref)
}

// NewFzFont allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzFont() *FzFont {
	return (*FzFont)(allocFzFontMemory(1))
}

// allocFzFontMemory allocates memory for type C.fz_font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzFontValue = unsafe.Sizeof([1]C.fz_font{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzFont) PassRef() *C.fz_font {
	if x == nil {
		x = (*FzFont)(allocFzFontMemory(1))
	}
	return (*C.fz_font)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzFontFlags) Ref() *C.fz_font_flags_t {
	if x == nil {
		return nil
	}
	return (*C.fz_font_flags_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzFontFlags) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzFontFlagsRef converts the C object reference into a raw struct reference without wrapping.
func NewFzFontFlagsRef(ref unsafe.Pointer) *FzFontFlags {
	return (*FzFontFlags)(ref)
}

// NewFzFontFlags allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzFontFlags() *FzFontFlags {
	return (*FzFontFlags)(allocFzFontFlagsMemory(1))
}

// allocFzFontFlagsMemory allocates memory for type C.fz_font_flags_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzFontFlagsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzFontFlagsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzFontFlagsValue = unsafe.Sizeof([1]C.fz_font_flags_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzFontFlags) PassRef() *C.fz_font_flags_t {
	if x == nil {
		x = (*FzFontFlags)(allocFzFontFlagsMemory(1))
	}
	return (*C.fz_font_flags_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzShaperData) Ref() *C.fz_shaper_data_t {
	if x == nil {
		return nil
	}
	return (*C.fz_shaper_data_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzShaperData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzShaperDataRef converts the C object reference into a raw struct reference without wrapping.
func NewFzShaperDataRef(ref unsafe.Pointer) *FzShaperData {
	return (*FzShaperData)(ref)
}

// NewFzShaperData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzShaperData() *FzShaperData {
	return (*FzShaperData)(allocFzShaperDataMemory(1))
}

// allocFzShaperDataMemory allocates memory for type C.fz_shaper_data_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzShaperDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzShaperDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzShaperDataValue = unsafe.Sizeof([1]C.fz_shaper_data_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzShaperData) PassRef() *C.fz_shaper_data_t {
	if x == nil {
		x = (*FzShaperData)(allocFzShaperDataMemory(1))
	}
	return (*C.fz_shaper_data_t)(unsafe.Pointer(x))
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

func (x FzLoadSystemFontFn) PassRef() (ref *C.fz_load_system_font_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzLoadSystemFontFnCF2C657Func == nil {
		fzLoadSystemFontFnCF2C657Func = x
	}
	return (*C.fz_load_system_font_fn)(C.fz_load_system_font_fn_cf2c657), nil
}

func NewFzLoadSystemFontFnRef(ref unsafe.Pointer) *FzLoadSystemFontFn {
	return (*FzLoadSystemFontFn)(ref)
}

//export fzLoadSystemFontFnCF2C657
func fzLoadSystemFontFnCF2C657(cctx *C.fz_context, cname *C.char, cbold C.int, citalic C.int, cneedsExactMetrics C.int) *C.fz_font {
	if fzLoadSystemFontFnCF2C657Func != nil {
		ctxcf2c657 := NewFzContextRef(unsafe.Pointer(cctx))
		namecf2c657 := packPCharString(cname)
		boldcf2c657 := (int32)(cbold)
		italiccf2c657 := (int32)(citalic)
		needsExactMetricscf2c657 := (int32)(cneedsExactMetrics)
		retcf2c657 := fzLoadSystemFontFnCF2C657Func(ctxcf2c657, namecf2c657, boldcf2c657, italiccf2c657, needsExactMetricscf2c657)
		ret, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&retcf2c657)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzLoadSystemFontFnCF2C657Func FzLoadSystemFontFn

func (x FzLoadSystemCjkFontFn) PassRef() (ref *C.fz_load_system_cjk_font_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzLoadSystemCjkFontFnB491FED9Func == nil {
		fzLoadSystemCjkFontFnB491FED9Func = x
	}
	return (*C.fz_load_system_cjk_font_fn)(C.fz_load_system_cjk_font_fn_b491fed9), nil
}

func NewFzLoadSystemCjkFontFnRef(ref unsafe.Pointer) *FzLoadSystemCjkFontFn {
	return (*FzLoadSystemCjkFontFn)(ref)
}

//export fzLoadSystemCjkFontFnB491FED9
func fzLoadSystemCjkFontFnB491FED9(cctx *C.fz_context, cname *C.char, cros C.int, cserif C.int) *C.fz_font {
	if fzLoadSystemCjkFontFnB491FED9Func != nil {
		ctxb491fed9 := NewFzContextRef(unsafe.Pointer(cctx))
		nameb491fed9 := packPCharString(cname)
		rosb491fed9 := (int32)(cros)
		serifb491fed9 := (int32)(cserif)
		retb491fed9 := fzLoadSystemCjkFontFnB491FED9Func(ctxb491fed9, nameb491fed9, rosb491fed9, serifb491fed9)
		ret, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&retb491fed9)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzLoadSystemCjkFontFnB491FED9Func FzLoadSystemCjkFontFn

func (x FzLoadSystemFallbackFontFn) PassRef() (ref *C.fz_load_system_fallback_font_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzLoadSystemFallbackFontFn36CB0CBFunc == nil {
		fzLoadSystemFallbackFontFn36CB0CBFunc = x
	}
	return (*C.fz_load_system_fallback_font_fn)(C.fz_load_system_fallback_font_fn_36cb0cb), nil
}

func NewFzLoadSystemFallbackFontFnRef(ref unsafe.Pointer) *FzLoadSystemFallbackFontFn {
	return (*FzLoadSystemFallbackFontFn)(ref)
}

//export fzLoadSystemFallbackFontFn36CB0CB
func fzLoadSystemFallbackFontFn36CB0CB(cctx *C.fz_context, cscript C.int, clanguage C.int, cserif C.int, cbold C.int, citalic C.int) *C.fz_font {
	if fzLoadSystemFallbackFontFn36CB0CBFunc != nil {
		ctx36cb0cb := NewFzContextRef(unsafe.Pointer(cctx))
		script36cb0cb := (int32)(cscript)
		language36cb0cb := (int32)(clanguage)
		serif36cb0cb := (int32)(cserif)
		bold36cb0cb := (int32)(cbold)
		italic36cb0cb := (int32)(citalic)
		ret36cb0cb := fzLoadSystemFallbackFontFn36CB0CBFunc(ctx36cb0cb, script36cb0cb, language36cb0cb, serif36cb0cb, bold36cb0cb, italic36cb0cb)
		ret, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ret36cb0cb)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzLoadSystemFallbackFontFn36CB0CBFunc FzLoadSystemFallbackFontFn

// Ref returns a reference to C object as it is.
func (x *FzPath) Ref() *C.fz_path {
	if x == nil {
		return nil
	}
	return (*C.fz_path)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzPath) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzPathRef converts the C object reference into a raw struct reference without wrapping.
func NewFzPathRef(ref unsafe.Pointer) *FzPath {
	return (*FzPath)(ref)
}

// NewFzPath allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzPath() *FzPath {
	return (*FzPath)(allocFzPathMemory(1))
}

// allocFzPathMemory allocates memory for type C.fz_path in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzPathMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzPathValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzPathValue = unsafe.Sizeof([1]C.fz_path{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzPath) PassRef() *C.fz_path {
	if x == nil {
		x = (*FzPath)(allocFzPathMemory(1))
	}
	return (*C.fz_path)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzStrokeState) Ref() *C.fz_stroke_state {
	if x == nil {
		return nil
	}
	return (*C.fz_stroke_state)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzStrokeState) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzStrokeStateRef converts the C object reference into a raw struct reference without wrapping.
func NewFzStrokeStateRef(ref unsafe.Pointer) *FzStrokeState {
	return (*FzStrokeState)(ref)
}

// NewFzStrokeState allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzStrokeState() *FzStrokeState {
	return (*FzStrokeState)(allocFzStrokeStateMemory(1))
}

// allocFzStrokeStateMemory allocates memory for type C.fz_stroke_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzStrokeStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzStrokeStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzStrokeStateValue = unsafe.Sizeof([1]C.fz_stroke_state{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzStrokeState) PassRef() *C.fz_stroke_state {
	if x == nil {
		x = (*FzStrokeState)(allocFzStrokeStateMemory(1))
	}
	return (*C.fz_stroke_state)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzPathWalker) Ref() *C.fz_path_walker {
	if x == nil {
		return nil
	}
	return (*C.fz_path_walker)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzPathWalker) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzPathWalkerRef converts the C object reference into a raw struct reference without wrapping.
func NewFzPathWalkerRef(ref unsafe.Pointer) *FzPathWalker {
	return (*FzPathWalker)(ref)
}

// NewFzPathWalker allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzPathWalker() *FzPathWalker {
	return (*FzPathWalker)(allocFzPathWalkerMemory(1))
}

// allocFzPathWalkerMemory allocates memory for type C.fz_path_walker in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzPathWalkerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzPathWalkerValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzPathWalkerValue = unsafe.Sizeof([1]C.fz_path_walker{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzPathWalker) PassRef() *C.fz_path_walker {
	if x == nil {
		x = (*FzPathWalker)(allocFzPathWalkerMemory(1))
	}
	return (*C.fz_path_walker)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzText) Ref() *C.fz_text {
	if x == nil {
		return nil
	}
	return (*C.fz_text)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzText) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzTextRef converts the C object reference into a raw struct reference without wrapping.
func NewFzTextRef(ref unsafe.Pointer) *FzText {
	return (*FzText)(ref)
}

// NewFzText allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzText() *FzText {
	return (*FzText)(allocFzTextMemory(1))
}

// allocFzTextMemory allocates memory for type C.fz_text in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzTextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzTextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzTextValue = unsafe.Sizeof([1]C.fz_text{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzText) PassRef() *C.fz_text {
	if x == nil {
		x = (*FzText)(allocFzTextMemory(1))
	}
	return (*C.fz_text)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzTextSpan) Ref() *C.fz_text_span {
	if x == nil {
		return nil
	}
	return (*C.fz_text_span)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzTextSpan) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzTextSpanRef converts the C object reference into a raw struct reference without wrapping.
func NewFzTextSpanRef(ref unsafe.Pointer) *FzTextSpan {
	return (*FzTextSpan)(ref)
}

// NewFzTextSpan allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzTextSpan() *FzTextSpan {
	return (*FzTextSpan)(allocFzTextSpanMemory(1))
}

// allocFzTextSpanMemory allocates memory for type C.fz_text_span in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzTextSpanMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzTextSpanValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzTextSpanValue = unsafe.Sizeof([1]C.fz_text_span{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzTextSpan) PassRef() *C.fz_text_span {
	if x == nil {
		x = (*FzTextSpan)(allocFzTextSpanMemory(1))
	}
	return (*C.fz_text_span)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzTextItem) Ref() *C.fz_text_item {
	if x == nil {
		return nil
	}
	return (*C.fz_text_item)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzTextItem) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzTextItemRef converts the C object reference into a raw struct reference without wrapping.
func NewFzTextItemRef(ref unsafe.Pointer) *FzTextItem {
	return (*FzTextItem)(ref)
}

// NewFzTextItem allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzTextItem() *FzTextItem {
	return (*FzTextItem)(allocFzTextItemMemory(1))
}

// allocFzTextItemMemory allocates memory for type C.fz_text_item in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzTextItemMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzTextItemValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzTextItemValue = unsafe.Sizeof([1]C.fz_text_item{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzTextItem) PassRef() *C.fz_text_item {
	if x == nil {
		x = (*FzTextItem)(allocFzTextItemMemory(1))
	}
	return (*C.fz_text_item)(unsafe.Pointer(x))
}

func (x FzCmmNewInstanceFn) PassRef() (ref *C.fz_cmm_new_instance_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzCmmNewInstanceFn3BC12687Func == nil {
		fzCmmNewInstanceFn3BC12687Func = x
	}
	return (*C.fz_cmm_new_instance_fn)(C.fz_cmm_new_instance_fn_3bc12687), nil
}

func NewFzCmmNewInstanceFnRef(ref unsafe.Pointer) *FzCmmNewInstanceFn {
	return (*FzCmmNewInstanceFn)(ref)
}

//export fzCmmNewInstanceFn3BC12687
func fzCmmNewInstanceFn3BC12687(cctx *C.fz_context) *C.fz_cmm_instance {
	if fzCmmNewInstanceFn3BC12687Func != nil {
		ctx3bc12687 := NewFzContextRef(unsafe.Pointer(cctx))
		ret3bc12687 := fzCmmNewInstanceFn3BC12687Func(ctx3bc12687)
		ret, _ := (*C.fz_cmm_instance)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ret3bc12687)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzCmmNewInstanceFn3BC12687Func FzCmmNewInstanceFn

func (x FzCmmDropInstanceFn) PassRef() (ref *C.fz_cmm_drop_instance_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzCmmDropInstanceFn8FCE668Func == nil {
		fzCmmDropInstanceFn8FCE668Func = x
	}
	return (*C.fz_cmm_drop_instance_fn)(C.fz_cmm_drop_instance_fn_8fce668), nil
}

func NewFzCmmDropInstanceFnRef(ref unsafe.Pointer) *FzCmmDropInstanceFn {
	return (*FzCmmDropInstanceFn)(ref)
}

//export fzCmmDropInstanceFn8FCE668
func fzCmmDropInstanceFn8FCE668(cinstance *C.fz_cmm_instance) {
	if fzCmmDropInstanceFn8FCE668Func != nil {
		instance8fce668 := (*FzCmmInstance)(unsafe.Pointer(cinstance))
		fzCmmDropInstanceFn8FCE668Func(instance8fce668)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzCmmDropInstanceFn8FCE668Func FzCmmDropInstanceFn

func (x FzCmmTransformPixmapFn) PassRef() (ref *C.fz_cmm_transform_pixmap_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzCmmTransformPixmapFnA9AD9719Func == nil {
		fzCmmTransformPixmapFnA9AD9719Func = x
	}
	return (*C.fz_cmm_transform_pixmap_fn)(C.fz_cmm_transform_pixmap_fn_a9ad9719), nil
}

func NewFzCmmTransformPixmapFnRef(ref unsafe.Pointer) *FzCmmTransformPixmapFn {
	return (*FzCmmTransformPixmapFn)(ref)
}

//export fzCmmTransformPixmapFnA9AD9719
func fzCmmTransformPixmapFnA9AD9719(cctx *C.fz_cmm_instance, clink *C.fz_icclink, cdst *C.fz_pixmap, csrc *C.fz_pixmap) {
	if fzCmmTransformPixmapFnA9AD9719Func != nil {
		ctxa9ad9719 := (*FzCmmInstance)(unsafe.Pointer(cctx))
		linka9ad9719 := (*FzIcclink)(unsafe.Pointer(clink))
		var dsta9ad9719 []FzPixmap
		packSFzPixmap(dsta9ad9719, cdst)
		var srca9ad9719 []FzPixmap
		packSFzPixmap(srca9ad9719, csrc)
		fzCmmTransformPixmapFnA9AD9719Func(ctxa9ad9719, linka9ad9719, dsta9ad9719, srca9ad9719)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzCmmTransformPixmapFnA9AD9719Func FzCmmTransformPixmapFn

func (x FzCmmTransformColorFn) PassRef() (ref *C.fz_cmm_transform_color_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzCmmTransformColorFn1CD2D69FFunc == nil {
		fzCmmTransformColorFn1CD2D69FFunc = x
	}
	return (*C.fz_cmm_transform_color_fn)(C.fz_cmm_transform_color_fn_1cd2d69f), nil
}

func NewFzCmmTransformColorFnRef(ref unsafe.Pointer) *FzCmmTransformColorFn {
	return (*FzCmmTransformColorFn)(ref)
}

//export fzCmmTransformColorFn1CD2D69F
func fzCmmTransformColorFn1CD2D69F(cctx *C.fz_cmm_instance, clink *C.fz_icclink, cdst *C.ushort, csrc *C.ushort) {
	if fzCmmTransformColorFn1CD2D69FFunc != nil {
		ctx1cd2d69f := (*FzCmmInstance)(unsafe.Pointer(cctx))
		link1cd2d69f := (*FzIcclink)(unsafe.Pointer(clink))
		var dst1cd2d69f []uint16
		hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&dst1cd2d69f))
		hxf69fe70.Data = uintptr(unsafe.Pointer(cdst))
		hxf69fe70.Cap = 0x7fffffff
		// hxf69fe70.Len = ?

		var src1cd2d69f []uint16
		hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&src1cd2d69f))
		hxf65bf54.Data = uintptr(unsafe.Pointer(csrc))
		hxf65bf54.Cap = 0x7fffffff
		// hxf65bf54.Len = ?

		fzCmmTransformColorFn1CD2D69FFunc(ctx1cd2d69f, link1cd2d69f, dst1cd2d69f, src1cd2d69f)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzCmmTransformColorFn1CD2D69FFunc FzCmmTransformColorFn

func (x FzCmmInitLinkFn) PassRef() (ref *C.fz_cmm_init_link_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzCmmInitLinkFn2C234A07Func == nil {
		fzCmmInitLinkFn2C234A07Func = x
	}
	return (*C.fz_cmm_init_link_fn)(C.fz_cmm_init_link_fn_2c234a07), nil
}

func NewFzCmmInitLinkFnRef(ref unsafe.Pointer) *FzCmmInitLinkFn {
	return (*FzCmmInitLinkFn)(ref)
}

//export fzCmmInitLinkFn2C234A07
func fzCmmInitLinkFn2C234A07(cctx *C.fz_cmm_instance, clink *C.fz_icclink, cdst *C.fz_iccprofile, cdstExtras C.int, csrc *C.fz_iccprofile, csrcExtras C.int, cprf *C.fz_iccprofile, crend *C.fz_color_params, ccmmFlags C.int, cnumBytes C.int, ccopySpots C.int) {
	if fzCmmInitLinkFn2C234A07Func != nil {
		ctx2c234a07 := (*FzCmmInstance)(unsafe.Pointer(cctx))
		link2c234a07 := (*FzIcclink)(unsafe.Pointer(clink))
		var dst2c234a07 []FzIccprofile
		hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&dst2c234a07))
		hxf3b8dbd.Data = uintptr(unsafe.Pointer(cdst))
		hxf3b8dbd.Cap = 0x7fffffff
		// hxf3b8dbd.Len = ?

		dstExtras2c234a07 := (int32)(cdstExtras)
		var src2c234a07 []FzIccprofile
		hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&src2c234a07))
		hxf7a6dff.Data = uintptr(unsafe.Pointer(csrc))
		hxf7a6dff.Cap = 0x7fffffff
		// hxf7a6dff.Len = ?

		srcExtras2c234a07 := (int32)(csrcExtras)
		var prf2c234a07 []FzIccprofile
		hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&prf2c234a07))
		hxfe48d67.Data = uintptr(unsafe.Pointer(cprf))
		hxfe48d67.Cap = 0x7fffffff
		// hxfe48d67.Len = ?

		var rend2c234a07 []FzColorParams
		packSFzColorParams(rend2c234a07, crend)
		cmmFlags2c234a07 := (int32)(ccmmFlags)
		numBytes2c234a07 := (int32)(cnumBytes)
		copySpots2c234a07 := (int32)(ccopySpots)
		fzCmmInitLinkFn2C234A07Func(ctx2c234a07, link2c234a07, dst2c234a07, dstExtras2c234a07, src2c234a07, srcExtras2c234a07, prf2c234a07, rend2c234a07, cmmFlags2c234a07, numBytes2c234a07, copySpots2c234a07)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzCmmInitLinkFn2C234A07Func FzCmmInitLinkFn

func (x FzCmmFinLinkFn) PassRef() (ref *C.fz_cmm_fin_link_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzCmmFinLinkFn2B624A1AFunc == nil {
		fzCmmFinLinkFn2B624A1AFunc = x
	}
	return (*C.fz_cmm_fin_link_fn)(C.fz_cmm_fin_link_fn_2b624a1a), nil
}

func NewFzCmmFinLinkFnRef(ref unsafe.Pointer) *FzCmmFinLinkFn {
	return (*FzCmmFinLinkFn)(ref)
}

//export fzCmmFinLinkFn2B624A1A
func fzCmmFinLinkFn2B624A1A(cctx *C.fz_cmm_instance, clink *C.fz_icclink) {
	if fzCmmFinLinkFn2B624A1AFunc != nil {
		ctx2b624a1a := (*FzCmmInstance)(unsafe.Pointer(cctx))
		link2b624a1a := (*FzIcclink)(unsafe.Pointer(clink))
		fzCmmFinLinkFn2B624A1AFunc(ctx2b624a1a, link2b624a1a)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzCmmFinLinkFn2B624A1AFunc FzCmmFinLinkFn

func (x FzCmmInitProfileFn) PassRef() (ref *C.fz_cmm_init_profile_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzCmmInitProfileFn5D5A5731Func == nil {
		fzCmmInitProfileFn5D5A5731Func = x
	}
	return (*C.fz_cmm_init_profile_fn)(C.fz_cmm_init_profile_fn_5d5a5731), nil
}

func NewFzCmmInitProfileFnRef(ref unsafe.Pointer) *FzCmmInitProfileFn {
	return (*FzCmmInitProfileFn)(ref)
}

//export fzCmmInitProfileFn5D5A5731
func fzCmmInitProfileFn5D5A5731(cctx *C.fz_cmm_instance, cprofile *C.fz_iccprofile) {
	if fzCmmInitProfileFn5D5A5731Func != nil {
		ctx5d5a5731 := (*FzCmmInstance)(unsafe.Pointer(cctx))
		profile5d5a5731 := (*FzIccprofile)(unsafe.Pointer(cprofile))
		fzCmmInitProfileFn5D5A5731Func(ctx5d5a5731, profile5d5a5731)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzCmmInitProfileFn5D5A5731Func FzCmmInitProfileFn

func (x FzCmmFinProfileFn) PassRef() (ref *C.fz_cmm_fin_profile_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzCmmFinProfileFn487F1613Func == nil {
		fzCmmFinProfileFn487F1613Func = x
	}
	return (*C.fz_cmm_fin_profile_fn)(C.fz_cmm_fin_profile_fn_487f1613), nil
}

func NewFzCmmFinProfileFnRef(ref unsafe.Pointer) *FzCmmFinProfileFn {
	return (*FzCmmFinProfileFn)(ref)
}

//export fzCmmFinProfileFn487F1613
func fzCmmFinProfileFn487F1613(cctx *C.fz_cmm_instance, cprofile *C.fz_iccprofile) {
	if fzCmmFinProfileFn487F1613Func != nil {
		ctx487f1613 := (*FzCmmInstance)(unsafe.Pointer(cctx))
		profile487f1613 := (*FzIccprofile)(unsafe.Pointer(cprofile))
		fzCmmFinProfileFn487F1613Func(ctx487f1613, profile487f1613)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzCmmFinProfileFn487F1613Func FzCmmFinProfileFn

// Ref returns a reference to C object as it is.
func (x *FzDevice) Ref() *C.fz_device {
	if x == nil {
		return nil
	}
	return (*C.fz_device)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzDevice) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzDeviceRef converts the C object reference into a raw struct reference without wrapping.
func NewFzDeviceRef(ref unsafe.Pointer) *FzDevice {
	return (*FzDevice)(ref)
}

// NewFzDevice allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzDevice() *FzDevice {
	return (*FzDevice)(allocFzDeviceMemory(1))
}

// allocFzDeviceMemory allocates memory for type C.fz_device in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzDeviceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzDeviceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzDeviceValue = unsafe.Sizeof([1]C.fz_device{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzDevice) PassRef() *C.fz_device {
	if x == nil {
		x = (*FzDevice)(allocFzDeviceMemory(1))
	}
	return (*C.fz_device)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzDeviceContainerStack) Ref() *C.fz_device_container_stack {
	if x == nil {
		return nil
	}
	return (*C.fz_device_container_stack)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzDeviceContainerStack) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzDeviceContainerStackRef converts the C object reference into a raw struct reference without wrapping.
func NewFzDeviceContainerStackRef(ref unsafe.Pointer) *FzDeviceContainerStack {
	return (*FzDeviceContainerStack)(ref)
}

// NewFzDeviceContainerStack allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzDeviceContainerStack() *FzDeviceContainerStack {
	return (*FzDeviceContainerStack)(allocFzDeviceContainerStackMemory(1))
}

// allocFzDeviceContainerStackMemory allocates memory for type C.fz_device_container_stack in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzDeviceContainerStackMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzDeviceContainerStackValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzDeviceContainerStackValue = unsafe.Sizeof([1]C.fz_device_container_stack{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzDeviceContainerStack) PassRef() *C.fz_device_container_stack {
	if x == nil {
		x = (*FzDeviceContainerStack)(allocFzDeviceContainerStackMemory(1))
	}
	return (*C.fz_device_container_stack)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzCookie) Ref() *C.fz_cookie {
	if x == nil {
		return nil
	}
	return (*C.fz_cookie)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzCookie) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzCookieRef converts the C object reference into a raw struct reference without wrapping.
func NewFzCookieRef(ref unsafe.Pointer) *FzCookie {
	return (*FzCookie)(ref)
}

// NewFzCookie allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzCookie() *FzCookie {
	return (*FzCookie)(allocFzCookieMemory(1))
}

// allocFzCookieMemory allocates memory for type C.fz_cookie in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzCookieMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzCookieValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzCookieValue = unsafe.Sizeof([1]C.fz_cookie{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzCookie) PassRef() *C.fz_cookie {
	if x == nil {
		x = (*FzCookie)(allocFzCookieMemory(1))
	}
	return (*C.fz_cookie)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzDrawOptions) Ref() *C.fz_draw_options {
	if x == nil {
		return nil
	}
	return (*C.fz_draw_options)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzDrawOptions) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzDrawOptionsRef converts the C object reference into a raw struct reference without wrapping.
func NewFzDrawOptionsRef(ref unsafe.Pointer) *FzDrawOptions {
	return (*FzDrawOptions)(ref)
}

// NewFzDrawOptions allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzDrawOptions() *FzDrawOptions {
	return (*FzDrawOptions)(allocFzDrawOptionsMemory(1))
}

// allocFzDrawOptionsMemory allocates memory for type C.fz_draw_options in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzDrawOptionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzDrawOptionsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzDrawOptionsValue = unsafe.Sizeof([1]C.fz_draw_options{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzDrawOptions) PassRef() *C.fz_draw_options {
	if x == nil {
		x = (*FzDrawOptions)(allocFzDrawOptionsMemory(1))
	}
	return (*C.fz_draw_options)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzDisplayList) Ref() *C.fz_display_list {
	if x == nil {
		return nil
	}
	return (*C.fz_display_list)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzDisplayList) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzDisplayListRef converts the C object reference into a raw struct reference without wrapping.
func NewFzDisplayListRef(ref unsafe.Pointer) *FzDisplayList {
	return (*FzDisplayList)(ref)
}

// NewFzDisplayList allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzDisplayList() *FzDisplayList {
	return (*FzDisplayList)(allocFzDisplayListMemory(1))
}

// allocFzDisplayListMemory allocates memory for type C.fz_display_list in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzDisplayListMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzDisplayListValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzDisplayListValue = unsafe.Sizeof([1]C.fz_display_list{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzDisplayList) PassRef() *C.fz_display_list {
	if x == nil {
		x = (*FzDisplayList)(allocFzDisplayListMemory(1))
	}
	return (*C.fz_display_list)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzStextChar) Ref() *C.fz_stext_char {
	if x == nil {
		return nil
	}
	return (*C.fz_stext_char)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzStextChar) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzStextCharRef converts the C object reference into a raw struct reference without wrapping.
func NewFzStextCharRef(ref unsafe.Pointer) *FzStextChar {
	return (*FzStextChar)(ref)
}

// NewFzStextChar allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzStextChar() *FzStextChar {
	return (*FzStextChar)(allocFzStextCharMemory(1))
}

// allocFzStextCharMemory allocates memory for type C.fz_stext_char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzStextCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzStextCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzStextCharValue = unsafe.Sizeof([1]C.fz_stext_char{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzStextChar) PassRef() *C.fz_stext_char {
	if x == nil {
		x = (*FzStextChar)(allocFzStextCharMemory(1))
	}
	return (*C.fz_stext_char)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzStextLine) Ref() *C.fz_stext_line {
	if x == nil {
		return nil
	}
	return (*C.fz_stext_line)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzStextLine) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzStextLineRef converts the C object reference into a raw struct reference without wrapping.
func NewFzStextLineRef(ref unsafe.Pointer) *FzStextLine {
	return (*FzStextLine)(ref)
}

// NewFzStextLine allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzStextLine() *FzStextLine {
	return (*FzStextLine)(allocFzStextLineMemory(1))
}

// allocFzStextLineMemory allocates memory for type C.fz_stext_line in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzStextLineMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzStextLineValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzStextLineValue = unsafe.Sizeof([1]C.fz_stext_line{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzStextLine) PassRef() *C.fz_stext_line {
	if x == nil {
		x = (*FzStextLine)(allocFzStextLineMemory(1))
	}
	return (*C.fz_stext_line)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzStextBlock) Ref() *C.fz_stext_block {
	if x == nil {
		return nil
	}
	return (*C.fz_stext_block)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzStextBlock) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzStextBlockRef converts the C object reference into a raw struct reference without wrapping.
func NewFzStextBlockRef(ref unsafe.Pointer) *FzStextBlock {
	return (*FzStextBlock)(ref)
}

// NewFzStextBlock allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzStextBlock() *FzStextBlock {
	return (*FzStextBlock)(allocFzStextBlockMemory(1))
}

// allocFzStextBlockMemory allocates memory for type C.fz_stext_block in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzStextBlockMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzStextBlockValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzStextBlockValue = unsafe.Sizeof([1]C.fz_stext_block{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzStextBlock) PassRef() *C.fz_stext_block {
	if x == nil {
		x = (*FzStextBlock)(allocFzStextBlockMemory(1))
	}
	return (*C.fz_stext_block)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzStextPage) Ref() *C.fz_stext_page {
	if x == nil {
		return nil
	}
	return (*C.fz_stext_page)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzStextPage) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzStextPageRef converts the C object reference into a raw struct reference without wrapping.
func NewFzStextPageRef(ref unsafe.Pointer) *FzStextPage {
	return (*FzStextPage)(ref)
}

// NewFzStextPage allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzStextPage() *FzStextPage {
	return (*FzStextPage)(allocFzStextPageMemory(1))
}

// allocFzStextPageMemory allocates memory for type C.fz_stext_page in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzStextPageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzStextPageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzStextPageValue = unsafe.Sizeof([1]C.fz_stext_page{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzStextPage) PassRef() *C.fz_stext_page {
	if x == nil {
		x = (*FzStextPage)(allocFzStextPageMemory(1))
	}
	return (*C.fz_stext_page)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzStextOptions) Ref() *C.fz_stext_options {
	if x == nil {
		return nil
	}
	return (*C.fz_stext_options)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzStextOptions) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzStextOptionsRef converts the C object reference into a raw struct reference without wrapping.
func NewFzStextOptionsRef(ref unsafe.Pointer) *FzStextOptions {
	return (*FzStextOptions)(ref)
}

// NewFzStextOptions allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzStextOptions() *FzStextOptions {
	return (*FzStextOptions)(allocFzStextOptionsMemory(1))
}

// allocFzStextOptionsMemory allocates memory for type C.fz_stext_options in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzStextOptionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzStextOptionsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzStextOptionsValue = unsafe.Sizeof([1]C.fz_stext_options{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzStextOptions) PassRef() *C.fz_stext_options {
	if x == nil {
		x = (*FzStextOptions)(allocFzStextOptionsMemory(1))
	}
	return (*C.fz_stext_options)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzTransition) Ref() *C.fz_transition {
	if x == nil {
		return nil
	}
	return (*C.fz_transition)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzTransition) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzTransitionRef converts the C object reference into a raw struct reference without wrapping.
func NewFzTransitionRef(ref unsafe.Pointer) *FzTransition {
	return (*FzTransition)(ref)
}

// NewFzTransition allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzTransition() *FzTransition {
	return (*FzTransition)(allocFzTransitionMemory(1))
}

// allocFzTransitionMemory allocates memory for type C.fz_transition in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzTransitionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzTransitionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzTransitionValue = unsafe.Sizeof([1]C.fz_transition{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzTransition) PassRef() *C.fz_transition {
	if x == nil {
		x = (*FzTransition)(allocFzTransitionMemory(1))
	}
	return (*C.fz_transition)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzLink) Ref() *C.fz_link {
	if x == nil {
		return nil
	}
	return (*C.fz_link)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzLink) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzLinkRef converts the C object reference into a raw struct reference without wrapping.
func NewFzLinkRef(ref unsafe.Pointer) *FzLink {
	return (*FzLink)(ref)
}

// NewFzLink allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzLink() *FzLink {
	return (*FzLink)(allocFzLinkMemory(1))
}

// allocFzLinkMemory allocates memory for type C.fz_link in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzLinkMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzLinkValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzLinkValue = unsafe.Sizeof([1]C.fz_link{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzLink) PassRef() *C.fz_link {
	if x == nil {
		x = (*FzLink)(allocFzLinkMemory(1))
	}
	return (*C.fz_link)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzOutline) Ref() *C.fz_outline {
	if x == nil {
		return nil
	}
	return (*C.fz_outline)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzOutline) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzOutlineRef converts the C object reference into a raw struct reference without wrapping.
func NewFzOutlineRef(ref unsafe.Pointer) *FzOutline {
	return (*FzOutline)(ref)
}

// NewFzOutline allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzOutline() *FzOutline {
	return (*FzOutline)(allocFzOutlineMemory(1))
}

// allocFzOutlineMemory allocates memory for type C.fz_outline in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzOutlineMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzOutlineValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzOutlineValue = unsafe.Sizeof([1]C.fz_outline{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzOutline) PassRef() *C.fz_outline {
	if x == nil {
		x = (*FzOutline)(allocFzOutlineMemory(1))
	}
	return (*C.fz_outline)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzDocument) Ref() *C.fz_document {
	if x == nil {
		return nil
	}
	return (*C.fz_document)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzDocument) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzDocumentRef converts the C object reference into a raw struct reference without wrapping.
func NewFzDocumentRef(ref unsafe.Pointer) *FzDocument {
	return (*FzDocument)(ref)
}

// NewFzDocument allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzDocument() *FzDocument {
	return (*FzDocument)(allocFzDocumentMemory(1))
}

// allocFzDocumentMemory allocates memory for type C.fz_document in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzDocumentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzDocumentValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzDocumentValue = unsafe.Sizeof([1]C.fz_document{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzDocument) PassRef() *C.fz_document {
	if x == nil {
		x = (*FzDocument)(allocFzDocumentMemory(1))
	}
	return (*C.fz_document)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzDocumentHandler) Ref() *C.fz_document_handler {
	if x == nil {
		return nil
	}
	return (*C.fz_document_handler)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzDocumentHandler) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzDocumentHandlerRef converts the C object reference into a raw struct reference without wrapping.
func NewFzDocumentHandlerRef(ref unsafe.Pointer) *FzDocumentHandler {
	return (*FzDocumentHandler)(ref)
}

// NewFzDocumentHandler allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzDocumentHandler() *FzDocumentHandler {
	return (*FzDocumentHandler)(allocFzDocumentHandlerMemory(1))
}

// allocFzDocumentHandlerMemory allocates memory for type C.fz_document_handler in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzDocumentHandlerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzDocumentHandlerValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzDocumentHandlerValue = unsafe.Sizeof([1]C.fz_document_handler{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzDocumentHandler) PassRef() *C.fz_document_handler {
	if x == nil {
		x = (*FzDocumentHandler)(allocFzDocumentHandlerMemory(1))
	}
	return (*C.fz_document_handler)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzPage) Ref() *C.fz_page {
	if x == nil {
		return nil
	}
	return (*C.fz_page)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzPage) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzPageRef converts the C object reference into a raw struct reference without wrapping.
func NewFzPageRef(ref unsafe.Pointer) *FzPage {
	return (*FzPage)(ref)
}

// NewFzPage allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzPage() *FzPage {
	return (*FzPage)(allocFzPageMemory(1))
}

// allocFzPageMemory allocates memory for type C.fz_page in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzPageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzPageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzPageValue = unsafe.Sizeof([1]C.fz_page{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzPage) PassRef() *C.fz_page {
	if x == nil {
		x = (*FzPage)(allocFzPageMemory(1))
	}
	return (*C.fz_page)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzAnnot) Ref() *C.fz_annot {
	if x == nil {
		return nil
	}
	return (*C.fz_annot)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzAnnot) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzAnnotRef converts the C object reference into a raw struct reference without wrapping.
func NewFzAnnotRef(ref unsafe.Pointer) *FzAnnot {
	return (*FzAnnot)(ref)
}

// NewFzAnnot allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzAnnot() *FzAnnot {
	return (*FzAnnot)(allocFzAnnotMemory(1))
}

// allocFzAnnotMemory allocates memory for type C.fz_annot in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzAnnotMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzAnnotValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzAnnotValue = unsafe.Sizeof([1]C.fz_annot{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzAnnot) PassRef() *C.fz_annot {
	if x == nil {
		x = (*FzAnnot)(allocFzAnnotMemory(1))
	}
	return (*C.fz_annot)(unsafe.Pointer(x))
}

func (x FzDocumentDropFn) PassRef() (ref *C.fz_document_drop_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentDropFn199B99E3Func == nil {
		fzDocumentDropFn199B99E3Func = x
	}
	return (*C.fz_document_drop_fn)(C.fz_document_drop_fn_199b99e3), nil
}

func NewFzDocumentDropFnRef(ref unsafe.Pointer) *FzDocumentDropFn {
	return (*FzDocumentDropFn)(ref)
}

//export fzDocumentDropFn199B99E3
func fzDocumentDropFn199B99E3(cctx *C.fz_context, cdoc *C.fz_document) {
	if fzDocumentDropFn199B99E3Func != nil {
		ctx199b99e3 := NewFzContextRef(unsafe.Pointer(cctx))
		doc199b99e3 := NewFzDocumentRef(unsafe.Pointer(cdoc))
		fzDocumentDropFn199B99E3Func(ctx199b99e3, doc199b99e3)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentDropFn199B99E3Func FzDocumentDropFn

func (x FzDocumentNeedsPasswordFn) PassRef() (ref *C.fz_document_needs_password_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentNeedsPasswordFn7840F251Func == nil {
		fzDocumentNeedsPasswordFn7840F251Func = x
	}
	return (*C.fz_document_needs_password_fn)(C.fz_document_needs_password_fn_7840f251), nil
}

func NewFzDocumentNeedsPasswordFnRef(ref unsafe.Pointer) *FzDocumentNeedsPasswordFn {
	return (*FzDocumentNeedsPasswordFn)(ref)
}

//export fzDocumentNeedsPasswordFn7840F251
func fzDocumentNeedsPasswordFn7840F251(cctx *C.fz_context, cdoc *C.fz_document) C.int {
	if fzDocumentNeedsPasswordFn7840F251Func != nil {
		ctx7840f251 := NewFzContextRef(unsafe.Pointer(cctx))
		doc7840f251 := NewFzDocumentRef(unsafe.Pointer(cdoc))
		ret7840f251 := fzDocumentNeedsPasswordFn7840F251Func(ctx7840f251, doc7840f251)
		ret, _ := (C.int)(ret7840f251), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentNeedsPasswordFn7840F251Func FzDocumentNeedsPasswordFn

func (x FzDocumentAuthenticatePasswordFn) PassRef() (ref *C.fz_document_authenticate_password_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentAuthenticatePasswordFnCCF5E3DFunc == nil {
		fzDocumentAuthenticatePasswordFnCCF5E3DFunc = x
	}
	return (*C.fz_document_authenticate_password_fn)(C.fz_document_authenticate_password_fn_ccf5e3d), nil
}

func NewFzDocumentAuthenticatePasswordFnRef(ref unsafe.Pointer) *FzDocumentAuthenticatePasswordFn {
	return (*FzDocumentAuthenticatePasswordFn)(ref)
}

//export fzDocumentAuthenticatePasswordFnCCF5E3D
func fzDocumentAuthenticatePasswordFnCCF5E3D(cctx *C.fz_context, cdoc *C.fz_document, cpassword *C.char) C.int {
	if fzDocumentAuthenticatePasswordFnCCF5E3DFunc != nil {
		ctxccf5e3d := NewFzContextRef(unsafe.Pointer(cctx))
		docccf5e3d := NewFzDocumentRef(unsafe.Pointer(cdoc))
		passwordccf5e3d := packPCharString(cpassword)
		retccf5e3d := fzDocumentAuthenticatePasswordFnCCF5E3DFunc(ctxccf5e3d, docccf5e3d, passwordccf5e3d)
		ret, _ := (C.int)(retccf5e3d), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentAuthenticatePasswordFnCCF5E3DFunc FzDocumentAuthenticatePasswordFn

func (x FzDocumentHasPermissionFn) PassRef() (ref *C.fz_document_has_permission_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentHasPermissionFn64826A68Func == nil {
		fzDocumentHasPermissionFn64826A68Func = x
	}
	return (*C.fz_document_has_permission_fn)(C.fz_document_has_permission_fn_64826a68), nil
}

func NewFzDocumentHasPermissionFnRef(ref unsafe.Pointer) *FzDocumentHasPermissionFn {
	return (*FzDocumentHasPermissionFn)(ref)
}

//export fzDocumentHasPermissionFn64826A68
func fzDocumentHasPermissionFn64826A68(cctx *C.fz_context, cdoc *C.fz_document, cpermission C.fz_permission) C.int {
	if fzDocumentHasPermissionFn64826A68Func != nil {
		ctx64826a68 := NewFzContextRef(unsafe.Pointer(cctx))
		doc64826a68 := NewFzDocumentRef(unsafe.Pointer(cdoc))
		permission64826a68 := (FzPermission)(cpermission)
		ret64826a68 := fzDocumentHasPermissionFn64826A68Func(ctx64826a68, doc64826a68, permission64826a68)
		ret, _ := (C.int)(ret64826a68), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentHasPermissionFn64826A68Func FzDocumentHasPermissionFn

func (x FzDocumentLoadOutlineFn) PassRef() (ref *C.fz_document_load_outline_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentLoadOutlineFnAE85B015Func == nil {
		fzDocumentLoadOutlineFnAE85B015Func = x
	}
	return (*C.fz_document_load_outline_fn)(C.fz_document_load_outline_fn_ae85b015), nil
}

func NewFzDocumentLoadOutlineFnRef(ref unsafe.Pointer) *FzDocumentLoadOutlineFn {
	return (*FzDocumentLoadOutlineFn)(ref)
}

//export fzDocumentLoadOutlineFnAE85B015
func fzDocumentLoadOutlineFnAE85B015(cctx *C.fz_context, cdoc *C.fz_document) *C.fz_outline {
	if fzDocumentLoadOutlineFnAE85B015Func != nil {
		ctxae85b015 := NewFzContextRef(unsafe.Pointer(cctx))
		docae85b015 := NewFzDocumentRef(unsafe.Pointer(cdoc))
		retae85b015 := fzDocumentLoadOutlineFnAE85B015Func(ctxae85b015, docae85b015)
		ret, _ := (*C.fz_outline)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&retae85b015)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentLoadOutlineFnAE85B015Func FzDocumentLoadOutlineFn

func (x FzDocumentLayoutFn) PassRef() (ref *C.fz_document_layout_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentLayoutFnCF5EAAA9Func == nil {
		fzDocumentLayoutFnCF5EAAA9Func = x
	}
	return (*C.fz_document_layout_fn)(C.fz_document_layout_fn_cf5eaaa9), nil
}

func NewFzDocumentLayoutFnRef(ref unsafe.Pointer) *FzDocumentLayoutFn {
	return (*FzDocumentLayoutFn)(ref)
}

//export fzDocumentLayoutFnCF5EAAA9
func fzDocumentLayoutFnCF5EAAA9(cctx *C.fz_context, cdoc *C.fz_document, cw C.float, ch C.float, cem C.float) {
	if fzDocumentLayoutFnCF5EAAA9Func != nil {
		ctxcf5eaaa9 := NewFzContextRef(unsafe.Pointer(cctx))
		doccf5eaaa9 := NewFzDocumentRef(unsafe.Pointer(cdoc))
		wcf5eaaa9 := (float32)(cw)
		hcf5eaaa9 := (float32)(ch)
		emcf5eaaa9 := (float32)(cem)
		fzDocumentLayoutFnCF5EAAA9Func(ctxcf5eaaa9, doccf5eaaa9, wcf5eaaa9, hcf5eaaa9, emcf5eaaa9)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentLayoutFnCF5EAAA9Func FzDocumentLayoutFn

func (x FzDocumentResolveLinkFn) PassRef() (ref *C.fz_document_resolve_link_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentResolveLinkFnF25A9656Func == nil {
		fzDocumentResolveLinkFnF25A9656Func = x
	}
	return (*C.fz_document_resolve_link_fn)(C.fz_document_resolve_link_fn_f25a9656), nil
}

func NewFzDocumentResolveLinkFnRef(ref unsafe.Pointer) *FzDocumentResolveLinkFn {
	return (*FzDocumentResolveLinkFn)(ref)
}

//export fzDocumentResolveLinkFnF25A9656
func fzDocumentResolveLinkFnF25A9656(cctx *C.fz_context, cdoc *C.fz_document, curi *C.char, cxp *C.float, cyp *C.float) C.int {
	if fzDocumentResolveLinkFnF25A9656Func != nil {
		ctxf25a9656 := NewFzContextRef(unsafe.Pointer(cctx))
		docf25a9656 := NewFzDocumentRef(unsafe.Pointer(cdoc))
		urif25a9656 := packPCharString(curi)
		var xpf25a9656 []float32
		hxf4171bf := (*sliceHeader)(unsafe.Pointer(&xpf25a9656))
		hxf4171bf.Data = uintptr(unsafe.Pointer(cxp))
		hxf4171bf.Cap = 0x7fffffff
		// hxf4171bf.Len = ?

		var ypf25a9656 []float32
		hxf058b18 := (*sliceHeader)(unsafe.Pointer(&ypf25a9656))
		hxf058b18.Data = uintptr(unsafe.Pointer(cyp))
		hxf058b18.Cap = 0x7fffffff
		// hxf058b18.Len = ?

		retf25a9656 := fzDocumentResolveLinkFnF25A9656Func(ctxf25a9656, docf25a9656, urif25a9656, xpf25a9656, ypf25a9656)
		ret, _ := (C.int)(retf25a9656), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentResolveLinkFnF25A9656Func FzDocumentResolveLinkFn

func (x FzDocumentCountPagesFn) PassRef() (ref *C.fz_document_count_pages_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentCountPagesFn20F867E7Func == nil {
		fzDocumentCountPagesFn20F867E7Func = x
	}
	return (*C.fz_document_count_pages_fn)(C.fz_document_count_pages_fn_20f867e7), nil
}

func NewFzDocumentCountPagesFnRef(ref unsafe.Pointer) *FzDocumentCountPagesFn {
	return (*FzDocumentCountPagesFn)(ref)
}

//export fzDocumentCountPagesFn20F867E7
func fzDocumentCountPagesFn20F867E7(cctx *C.fz_context, cdoc *C.fz_document) C.int {
	if fzDocumentCountPagesFn20F867E7Func != nil {
		ctx20f867e7 := NewFzContextRef(unsafe.Pointer(cctx))
		doc20f867e7 := NewFzDocumentRef(unsafe.Pointer(cdoc))
		ret20f867e7 := fzDocumentCountPagesFn20F867E7Func(ctx20f867e7, doc20f867e7)
		ret, _ := (C.int)(ret20f867e7), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentCountPagesFn20F867E7Func FzDocumentCountPagesFn

func (x FzDocumentLoadPageFn) PassRef() (ref *C.fz_document_load_page_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentLoadPageFnA32C9877Func == nil {
		fzDocumentLoadPageFnA32C9877Func = x
	}
	return (*C.fz_document_load_page_fn)(C.fz_document_load_page_fn_a32c9877), nil
}

func NewFzDocumentLoadPageFnRef(ref unsafe.Pointer) *FzDocumentLoadPageFn {
	return (*FzDocumentLoadPageFn)(ref)
}

//export fzDocumentLoadPageFnA32C9877
func fzDocumentLoadPageFnA32C9877(cctx *C.fz_context, cdoc *C.fz_document, cnumber C.int) *C.fz_page {
	if fzDocumentLoadPageFnA32C9877Func != nil {
		ctxa32c9877 := NewFzContextRef(unsafe.Pointer(cctx))
		doca32c9877 := NewFzDocumentRef(unsafe.Pointer(cdoc))
		numbera32c9877 := (int32)(cnumber)
		reta32c9877 := fzDocumentLoadPageFnA32C9877Func(ctxa32c9877, doca32c9877, numbera32c9877)
		ret, _ := (*C.fz_page)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&reta32c9877)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentLoadPageFnA32C9877Func FzDocumentLoadPageFn

func (x FzDocumentLookupMetadataFn) PassRef() (ref *C.fz_document_lookup_metadata_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentLookupMetadataFn1F9B8013Func == nil {
		fzDocumentLookupMetadataFn1F9B8013Func = x
	}
	return (*C.fz_document_lookup_metadata_fn)(C.fz_document_lookup_metadata_fn_1f9b8013), nil
}

func NewFzDocumentLookupMetadataFnRef(ref unsafe.Pointer) *FzDocumentLookupMetadataFn {
	return (*FzDocumentLookupMetadataFn)(ref)
}

//export fzDocumentLookupMetadataFn1F9B8013
func fzDocumentLookupMetadataFn1F9B8013(cctx *C.fz_context, cdoc *C.fz_document, ckey *C.char, cbuf *C.char, csize C.int) C.int {
	if fzDocumentLookupMetadataFn1F9B8013Func != nil {
		ctx1f9b8013 := NewFzContextRef(unsafe.Pointer(cctx))
		doc1f9b8013 := NewFzDocumentRef(unsafe.Pointer(cdoc))
		key1f9b8013 := packPCharString(ckey)
		var buf1f9b8013 []byte
		hxff6bc57 := (*sliceHeader)(unsafe.Pointer(&buf1f9b8013))
		hxff6bc57.Data = uintptr(unsafe.Pointer(cbuf))
		hxff6bc57.Cap = 0x7fffffff
		// hxff6bc57.Len = ?

		size1f9b8013 := (int32)(csize)
		ret1f9b8013 := fzDocumentLookupMetadataFn1F9B8013Func(ctx1f9b8013, doc1f9b8013, key1f9b8013, buf1f9b8013, size1f9b8013)
		ret, _ := (C.int)(ret1f9b8013), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentLookupMetadataFn1F9B8013Func FzDocumentLookupMetadataFn

func (x FzDocumentOutputIntentFn) PassRef() (ref *C.fz_document_output_intent_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentOutputIntentFn3E3B0BCFFunc == nil {
		fzDocumentOutputIntentFn3E3B0BCFFunc = x
	}
	return (*C.fz_document_output_intent_fn)(C.fz_document_output_intent_fn_3e3b0bcf), nil
}

func NewFzDocumentOutputIntentFnRef(ref unsafe.Pointer) *FzDocumentOutputIntentFn {
	return (*FzDocumentOutputIntentFn)(ref)
}

//export fzDocumentOutputIntentFn3E3B0BCF
func fzDocumentOutputIntentFn3E3B0BCF(cctx *C.fz_context, cdoc *C.fz_document) *C.fz_colorspace {
	if fzDocumentOutputIntentFn3E3B0BCFFunc != nil {
		ctx3e3b0bcf := NewFzContextRef(unsafe.Pointer(cctx))
		doc3e3b0bcf := NewFzDocumentRef(unsafe.Pointer(cdoc))
		ret3e3b0bcf := fzDocumentOutputIntentFn3E3B0BCFFunc(ctx3e3b0bcf, doc3e3b0bcf)
		ret, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ret3e3b0bcf)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentOutputIntentFn3E3B0BCFFunc FzDocumentOutputIntentFn

func (x FzDocumentMakeBookmarkFn) PassRef() (ref *C.fz_document_make_bookmark_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentMakeBookmarkFnCD7A2755Func == nil {
		fzDocumentMakeBookmarkFnCD7A2755Func = x
	}
	return (*C.fz_document_make_bookmark_fn)(C.fz_document_make_bookmark_fn_cd7a2755), nil
}

func NewFzDocumentMakeBookmarkFnRef(ref unsafe.Pointer) *FzDocumentMakeBookmarkFn {
	return (*FzDocumentMakeBookmarkFn)(ref)
}

//export fzDocumentMakeBookmarkFnCD7A2755
func fzDocumentMakeBookmarkFnCD7A2755(cctx *C.fz_context, cdoc *C.fz_document, cpage C.int) C.fz_bookmark {
	if fzDocumentMakeBookmarkFnCD7A2755Func != nil {
		ctxcd7a2755 := NewFzContextRef(unsafe.Pointer(cctx))
		doccd7a2755 := NewFzDocumentRef(unsafe.Pointer(cdoc))
		pagecd7a2755 := (int32)(cpage)
		retcd7a2755 := fzDocumentMakeBookmarkFnCD7A2755Func(ctxcd7a2755, doccd7a2755, pagecd7a2755)
		ret, _ := (C.fz_bookmark)(retcd7a2755), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentMakeBookmarkFnCD7A2755Func FzDocumentMakeBookmarkFn

func (x FzDocumentLookupBookmarkFn) PassRef() (ref *C.fz_document_lookup_bookmark_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentLookupBookmarkFn5171746FFunc == nil {
		fzDocumentLookupBookmarkFn5171746FFunc = x
	}
	return (*C.fz_document_lookup_bookmark_fn)(C.fz_document_lookup_bookmark_fn_5171746f), nil
}

func NewFzDocumentLookupBookmarkFnRef(ref unsafe.Pointer) *FzDocumentLookupBookmarkFn {
	return (*FzDocumentLookupBookmarkFn)(ref)
}

//export fzDocumentLookupBookmarkFn5171746F
func fzDocumentLookupBookmarkFn5171746F(cctx *C.fz_context, cdoc *C.fz_document, cmark C.fz_bookmark) C.int {
	if fzDocumentLookupBookmarkFn5171746FFunc != nil {
		ctx5171746f := NewFzContextRef(unsafe.Pointer(cctx))
		doc5171746f := NewFzDocumentRef(unsafe.Pointer(cdoc))
		mark5171746f := (FzBookmark)(cmark)
		ret5171746f := fzDocumentLookupBookmarkFn5171746FFunc(ctx5171746f, doc5171746f, mark5171746f)
		ret, _ := (C.int)(ret5171746f), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentLookupBookmarkFn5171746FFunc FzDocumentLookupBookmarkFn

func (x FzPageDropPageFn) PassRef() (ref *C.fz_page_drop_page_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzPageDropPageFnE86AD7C7Func == nil {
		fzPageDropPageFnE86AD7C7Func = x
	}
	return (*C.fz_page_drop_page_fn)(C.fz_page_drop_page_fn_e86ad7c7), nil
}

func NewFzPageDropPageFnRef(ref unsafe.Pointer) *FzPageDropPageFn {
	return (*FzPageDropPageFn)(ref)
}

//export fzPageDropPageFnE86AD7C7
func fzPageDropPageFnE86AD7C7(cctx *C.fz_context, cpage *C.fz_page) {
	if fzPageDropPageFnE86AD7C7Func != nil {
		ctxe86ad7c7 := NewFzContextRef(unsafe.Pointer(cctx))
		pagee86ad7c7 := NewFzPageRef(unsafe.Pointer(cpage))
		fzPageDropPageFnE86AD7C7Func(ctxe86ad7c7, pagee86ad7c7)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzPageDropPageFnE86AD7C7Func FzPageDropPageFn

// packSFzRect reads sliced Go data structure out from plain C format.
func packSFzRect(v []FzRect, ptr0 *C.fz_rect) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFzRectValue]C.fz_rect)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFzRectRef(unsafe.Pointer(&ptr1))
	}
}

func (x FzPageBoundPageFn) PassRef() (ref *C.fz_page_bound_page_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzPageBoundPageFnA77BC5EDFunc == nil {
		fzPageBoundPageFnA77BC5EDFunc = x
	}
	return (*C.fz_page_bound_page_fn)(C.fz_page_bound_page_fn_a77bc5ed), nil
}

func NewFzPageBoundPageFnRef(ref unsafe.Pointer) *FzPageBoundPageFn {
	return (*FzPageBoundPageFn)(ref)
}

//export fzPageBoundPageFnA77BC5ED
func fzPageBoundPageFnA77BC5ED(cctx *C.fz_context, cpage *C.fz_page, carg2 *C.fz_rect) *C.fz_rect {
	if fzPageBoundPageFnA77BC5EDFunc != nil {
		ctxa77bc5ed := NewFzContextRef(unsafe.Pointer(cctx))
		pagea77bc5ed := NewFzPageRef(unsafe.Pointer(cpage))
		var arg2a77bc5ed []FzRect
		packSFzRect(arg2a77bc5ed, carg2)
		reta77bc5ed := fzPageBoundPageFnA77BC5EDFunc(ctxa77bc5ed, pagea77bc5ed, arg2a77bc5ed)
		ret, _ := (*C.fz_rect)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&reta77bc5ed)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzPageBoundPageFnA77BC5EDFunc FzPageBoundPageFn

// packSFzDevice reads sliced Go data structure out from plain C format.
func packSFzDevice(v []FzDevice, ptr0 *C.fz_device) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFzDeviceValue]C.fz_device)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFzDeviceRef(unsafe.Pointer(&ptr1))
	}
}

// packSFzMatrix reads sliced Go data structure out from plain C format.
func packSFzMatrix(v []FzMatrix, ptr0 *C.fz_matrix) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFzMatrixValue]C.fz_matrix)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFzMatrixRef(unsafe.Pointer(&ptr1))
	}
}

// packSFzCookie reads sliced Go data structure out from plain C format.
func packSFzCookie(v []FzCookie, ptr0 *C.fz_cookie) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFzCookieValue]C.fz_cookie)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFzCookieRef(unsafe.Pointer(&ptr1))
	}
}

func (x FzPageRunPageContentsFn) PassRef() (ref *C.fz_page_run_page_contents_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzPageRunPageContentsFn7710BE3EFunc == nil {
		fzPageRunPageContentsFn7710BE3EFunc = x
	}
	return (*C.fz_page_run_page_contents_fn)(C.fz_page_run_page_contents_fn_7710be3e), nil
}

func NewFzPageRunPageContentsFnRef(ref unsafe.Pointer) *FzPageRunPageContentsFn {
	return (*FzPageRunPageContentsFn)(ref)
}

//export fzPageRunPageContentsFn7710BE3E
func fzPageRunPageContentsFn7710BE3E(cctx *C.fz_context, cpage *C.fz_page, cdev *C.fz_device, ctransform *C.fz_matrix, ccookie *C.fz_cookie) {
	if fzPageRunPageContentsFn7710BE3EFunc != nil {
		ctx7710be3e := NewFzContextRef(unsafe.Pointer(cctx))
		page7710be3e := NewFzPageRef(unsafe.Pointer(cpage))
		var dev7710be3e []FzDevice
		packSFzDevice(dev7710be3e, cdev)
		var transform7710be3e []FzMatrix
		packSFzMatrix(transform7710be3e, ctransform)
		var cookie7710be3e []FzCookie
		packSFzCookie(cookie7710be3e, ccookie)
		fzPageRunPageContentsFn7710BE3EFunc(ctx7710be3e, page7710be3e, dev7710be3e, transform7710be3e, cookie7710be3e)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzPageRunPageContentsFn7710BE3EFunc FzPageRunPageContentsFn

func (x FzPageLoadLinksFn) PassRef() (ref *C.fz_page_load_links_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzPageLoadLinksFn40246AC6Func == nil {
		fzPageLoadLinksFn40246AC6Func = x
	}
	return (*C.fz_page_load_links_fn)(C.fz_page_load_links_fn_40246ac6), nil
}

func NewFzPageLoadLinksFnRef(ref unsafe.Pointer) *FzPageLoadLinksFn {
	return (*FzPageLoadLinksFn)(ref)
}

//export fzPageLoadLinksFn40246AC6
func fzPageLoadLinksFn40246AC6(cctx *C.fz_context, cpage *C.fz_page) *C.fz_link {
	if fzPageLoadLinksFn40246AC6Func != nil {
		ctx40246ac6 := NewFzContextRef(unsafe.Pointer(cctx))
		page40246ac6 := NewFzPageRef(unsafe.Pointer(cpage))
		ret40246ac6 := fzPageLoadLinksFn40246AC6Func(ctx40246ac6, page40246ac6)
		ret, _ := (*C.fz_link)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ret40246ac6)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzPageLoadLinksFn40246AC6Func FzPageLoadLinksFn

func (x FzPageFirstAnnotFn) PassRef() (ref *C.fz_page_first_annot_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzPageFirstAnnotFn96BF83A2Func == nil {
		fzPageFirstAnnotFn96BF83A2Func = x
	}
	return (*C.fz_page_first_annot_fn)(C.fz_page_first_annot_fn_96bf83a2), nil
}

func NewFzPageFirstAnnotFnRef(ref unsafe.Pointer) *FzPageFirstAnnotFn {
	return (*FzPageFirstAnnotFn)(ref)
}

//export fzPageFirstAnnotFn96BF83A2
func fzPageFirstAnnotFn96BF83A2(cctx *C.fz_context, cpage *C.fz_page) *C.fz_annot {
	if fzPageFirstAnnotFn96BF83A2Func != nil {
		ctx96bf83a2 := NewFzContextRef(unsafe.Pointer(cctx))
		page96bf83a2 := NewFzPageRef(unsafe.Pointer(cpage))
		ret96bf83a2 := fzPageFirstAnnotFn96BF83A2Func(ctx96bf83a2, page96bf83a2)
		ret, _ := (*C.fz_annot)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ret96bf83a2)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzPageFirstAnnotFn96BF83A2Func FzPageFirstAnnotFn

// packSFzTransition reads sliced Go data structure out from plain C format.
func packSFzTransition(v []FzTransition, ptr0 *C.fz_transition) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFzTransitionValue]C.fz_transition)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFzTransitionRef(unsafe.Pointer(&ptr1))
	}
}

func (x FzPagePagePresentationFn) PassRef() (ref *C.fz_page_page_presentation_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzPagePagePresentationFn4C62D63FFunc == nil {
		fzPagePagePresentationFn4C62D63FFunc = x
	}
	return (*C.fz_page_page_presentation_fn)(C.fz_page_page_presentation_fn_4c62d63f), nil
}

func NewFzPagePagePresentationFnRef(ref unsafe.Pointer) *FzPagePagePresentationFn {
	return (*FzPagePagePresentationFn)(ref)
}

//export fzPagePagePresentationFn4C62D63F
func fzPagePagePresentationFn4C62D63F(cctx *C.fz_context, cpage *C.fz_page, ctransition *C.fz_transition, cduration *C.float) *C.fz_transition {
	if fzPagePagePresentationFn4C62D63FFunc != nil {
		ctx4c62d63f := NewFzContextRef(unsafe.Pointer(cctx))
		page4c62d63f := NewFzPageRef(unsafe.Pointer(cpage))
		var transition4c62d63f []FzTransition
		packSFzTransition(transition4c62d63f, ctransition)
		var duration4c62d63f []float32
		hxf5fa529 := (*sliceHeader)(unsafe.Pointer(&duration4c62d63f))
		hxf5fa529.Data = uintptr(unsafe.Pointer(cduration))
		hxf5fa529.Cap = 0x7fffffff
		// hxf5fa529.Len = ?

		ret4c62d63f := fzPagePagePresentationFn4C62D63FFunc(ctx4c62d63f, page4c62d63f, transition4c62d63f, duration4c62d63f)
		ret, _ := (*C.fz_transition)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ret4c62d63f)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzPagePagePresentationFn4C62D63FFunc FzPagePagePresentationFn

func (x FzPageControlSeparationFn) PassRef() (ref *C.fz_page_control_separation_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzPageControlSeparationFnA66789C6Func == nil {
		fzPageControlSeparationFnA66789C6Func = x
	}
	return (*C.fz_page_control_separation_fn)(C.fz_page_control_separation_fn_a66789c6), nil
}

func NewFzPageControlSeparationFnRef(ref unsafe.Pointer) *FzPageControlSeparationFn {
	return (*FzPageControlSeparationFn)(ref)
}

//export fzPageControlSeparationFnA66789C6
func fzPageControlSeparationFnA66789C6(cctx *C.fz_context, cpage *C.fz_page, cseparation C.int, cdisable C.int) {
	if fzPageControlSeparationFnA66789C6Func != nil {
		ctxa66789c6 := NewFzContextRef(unsafe.Pointer(cctx))
		pagea66789c6 := NewFzPageRef(unsafe.Pointer(cpage))
		separationa66789c6 := (int32)(cseparation)
		disablea66789c6 := (int32)(cdisable)
		fzPageControlSeparationFnA66789C6Func(ctxa66789c6, pagea66789c6, separationa66789c6, disablea66789c6)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzPageControlSeparationFnA66789C6Func FzPageControlSeparationFn

func (x FzPageSeparationDisabledFn) PassRef() (ref *C.fz_page_separation_disabled_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzPageSeparationDisabledFn6286727EFunc == nil {
		fzPageSeparationDisabledFn6286727EFunc = x
	}
	return (*C.fz_page_separation_disabled_fn)(C.fz_page_separation_disabled_fn_6286727e), nil
}

func NewFzPageSeparationDisabledFnRef(ref unsafe.Pointer) *FzPageSeparationDisabledFn {
	return (*FzPageSeparationDisabledFn)(ref)
}

//export fzPageSeparationDisabledFn6286727E
func fzPageSeparationDisabledFn6286727E(cctx *C.fz_context, cpage *C.fz_page, cseparation C.int) C.int {
	if fzPageSeparationDisabledFn6286727EFunc != nil {
		ctx6286727e := NewFzContextRef(unsafe.Pointer(cctx))
		page6286727e := NewFzPageRef(unsafe.Pointer(cpage))
		separation6286727e := (int32)(cseparation)
		ret6286727e := fzPageSeparationDisabledFn6286727EFunc(ctx6286727e, page6286727e, separation6286727e)
		ret, _ := (C.int)(ret6286727e), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzPageSeparationDisabledFn6286727EFunc FzPageSeparationDisabledFn

func (x FzPageSeparationsFn) PassRef() (ref *C.fz_page_separations_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzPageSeparationsFn854F23A7Func == nil {
		fzPageSeparationsFn854F23A7Func = x
	}
	return (*C.fz_page_separations_fn)(C.fz_page_separations_fn_854f23a7), nil
}

func NewFzPageSeparationsFnRef(ref unsafe.Pointer) *FzPageSeparationsFn {
	return (*FzPageSeparationsFn)(ref)
}

//export fzPageSeparationsFn854F23A7
func fzPageSeparationsFn854F23A7(cctx *C.fz_context, cpage *C.fz_page) *C.fz_separations {
	if fzPageSeparationsFn854F23A7Func != nil {
		ctx854f23a7 := NewFzContextRef(unsafe.Pointer(cctx))
		page854f23a7 := NewFzPageRef(unsafe.Pointer(cpage))
		ret854f23a7 := fzPageSeparationsFn854F23A7Func(ctx854f23a7, page854f23a7)
		ret, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ret854f23a7)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzPageSeparationsFn854F23A7Func FzPageSeparationsFn

func (x FzPageUsesOverprintFn) PassRef() (ref *C.fz_page_uses_overprint_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzPageUsesOverprintFn77475D4DFunc == nil {
		fzPageUsesOverprintFn77475D4DFunc = x
	}
	return (*C.fz_page_uses_overprint_fn)(C.fz_page_uses_overprint_fn_77475d4d), nil
}

func NewFzPageUsesOverprintFnRef(ref unsafe.Pointer) *FzPageUsesOverprintFn {
	return (*FzPageUsesOverprintFn)(ref)
}

//export fzPageUsesOverprintFn77475D4D
func fzPageUsesOverprintFn77475D4D(cctx *C.fz_context, cpage *C.fz_page) C.int {
	if fzPageUsesOverprintFn77475D4DFunc != nil {
		ctx77475d4d := NewFzContextRef(unsafe.Pointer(cctx))
		page77475d4d := NewFzPageRef(unsafe.Pointer(cpage))
		ret77475d4d := fzPageUsesOverprintFn77475D4DFunc(ctx77475d4d, page77475d4d)
		ret, _ := (C.int)(ret77475d4d), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzPageUsesOverprintFn77475D4DFunc FzPageUsesOverprintFn

func (x FzAnnotDropFn) PassRef() (ref *C.fz_annot_drop_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzAnnotDropFn30A53795Func == nil {
		fzAnnotDropFn30A53795Func = x
	}
	return (*C.fz_annot_drop_fn)(C.fz_annot_drop_fn_30a53795), nil
}

func NewFzAnnotDropFnRef(ref unsafe.Pointer) *FzAnnotDropFn {
	return (*FzAnnotDropFn)(ref)
}

//export fzAnnotDropFn30A53795
func fzAnnotDropFn30A53795(cctx *C.fz_context, cannot *C.fz_annot) {
	if fzAnnotDropFn30A53795Func != nil {
		ctx30a53795 := NewFzContextRef(unsafe.Pointer(cctx))
		annot30a53795 := NewFzAnnotRef(unsafe.Pointer(cannot))
		fzAnnotDropFn30A53795Func(ctx30a53795, annot30a53795)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzAnnotDropFn30A53795Func FzAnnotDropFn

func (x FzAnnotNextFn) PassRef() (ref *C.fz_annot_next_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzAnnotNextFnD7A4863DFunc == nil {
		fzAnnotNextFnD7A4863DFunc = x
	}
	return (*C.fz_annot_next_fn)(C.fz_annot_next_fn_d7a4863d), nil
}

func NewFzAnnotNextFnRef(ref unsafe.Pointer) *FzAnnotNextFn {
	return (*FzAnnotNextFn)(ref)
}

//export fzAnnotNextFnD7A4863D
func fzAnnotNextFnD7A4863D(cctx *C.fz_context, cannot *C.fz_annot) *C.fz_annot {
	if fzAnnotNextFnD7A4863DFunc != nil {
		ctxd7a4863d := NewFzContextRef(unsafe.Pointer(cctx))
		annotd7a4863d := NewFzAnnotRef(unsafe.Pointer(cannot))
		retd7a4863d := fzAnnotNextFnD7A4863DFunc(ctxd7a4863d, annotd7a4863d)
		ret, _ := (*C.fz_annot)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&retd7a4863d)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzAnnotNextFnD7A4863DFunc FzAnnotNextFn

func (x FzAnnotBoundFn) PassRef() (ref *C.fz_annot_bound_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzAnnotBoundFn81EFB60EFunc == nil {
		fzAnnotBoundFn81EFB60EFunc = x
	}
	return (*C.fz_annot_bound_fn)(C.fz_annot_bound_fn_81efb60e), nil
}

func NewFzAnnotBoundFnRef(ref unsafe.Pointer) *FzAnnotBoundFn {
	return (*FzAnnotBoundFn)(ref)
}

//export fzAnnotBoundFn81EFB60E
func fzAnnotBoundFn81EFB60E(cctx *C.fz_context, cannot *C.fz_annot, crect *C.fz_rect) *C.fz_rect {
	if fzAnnotBoundFn81EFB60EFunc != nil {
		ctx81efb60e := NewFzContextRef(unsafe.Pointer(cctx))
		annot81efb60e := NewFzAnnotRef(unsafe.Pointer(cannot))
		var rect81efb60e []FzRect
		packSFzRect(rect81efb60e, crect)
		ret81efb60e := fzAnnotBoundFn81EFB60EFunc(ctx81efb60e, annot81efb60e, rect81efb60e)
		ret, _ := (*C.fz_rect)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ret81efb60e)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzAnnotBoundFn81EFB60EFunc FzAnnotBoundFn

func (x FzAnnotRunFn) PassRef() (ref *C.fz_annot_run_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzAnnotRunFnF3FF5201Func == nil {
		fzAnnotRunFnF3FF5201Func = x
	}
	return (*C.fz_annot_run_fn)(C.fz_annot_run_fn_f3ff5201), nil
}

func NewFzAnnotRunFnRef(ref unsafe.Pointer) *FzAnnotRunFn {
	return (*FzAnnotRunFn)(ref)
}

//export fzAnnotRunFnF3FF5201
func fzAnnotRunFnF3FF5201(cctx *C.fz_context, cannot *C.fz_annot, cdev *C.fz_device, ctransform *C.fz_matrix, ccookie *C.fz_cookie) {
	if fzAnnotRunFnF3FF5201Func != nil {
		ctxf3ff5201 := NewFzContextRef(unsafe.Pointer(cctx))
		annotf3ff5201 := NewFzAnnotRef(unsafe.Pointer(cannot))
		var devf3ff5201 []FzDevice
		packSFzDevice(devf3ff5201, cdev)
		var transformf3ff5201 []FzMatrix
		packSFzMatrix(transformf3ff5201, ctransform)
		var cookief3ff5201 []FzCookie
		packSFzCookie(cookief3ff5201, ccookie)
		fzAnnotRunFnF3FF5201Func(ctxf3ff5201, annotf3ff5201, devf3ff5201, transformf3ff5201, cookief3ff5201)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzAnnotRunFnF3FF5201Func FzAnnotRunFn

func (x FzDocumentOpenFn) PassRef() (ref *C.fz_document_open_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentOpenFnAC22541FFunc == nil {
		fzDocumentOpenFnAC22541FFunc = x
	}
	return (*C.fz_document_open_fn)(C.fz_document_open_fn_ac22541f), nil
}

func NewFzDocumentOpenFnRef(ref unsafe.Pointer) *FzDocumentOpenFn {
	return (*FzDocumentOpenFn)(ref)
}

//export fzDocumentOpenFnAC22541F
func fzDocumentOpenFnAC22541F(cctx *C.fz_context, cfilename *C.char) *C.fz_document {
	if fzDocumentOpenFnAC22541FFunc != nil {
		ctxac22541f := NewFzContextRef(unsafe.Pointer(cctx))
		filenameac22541f := packPCharString(cfilename)
		retac22541f := fzDocumentOpenFnAC22541FFunc(ctxac22541f, filenameac22541f)
		ret, _ := (*C.fz_document)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&retac22541f)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentOpenFnAC22541FFunc FzDocumentOpenFn

func (x FzDocumentOpenWithStreamFn) PassRef() (ref *C.fz_document_open_with_stream_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentOpenWithStreamFnD625D461Func == nil {
		fzDocumentOpenWithStreamFnD625D461Func = x
	}
	return (*C.fz_document_open_with_stream_fn)(C.fz_document_open_with_stream_fn_d625d461), nil
}

func NewFzDocumentOpenWithStreamFnRef(ref unsafe.Pointer) *FzDocumentOpenWithStreamFn {
	return (*FzDocumentOpenWithStreamFn)(ref)
}

//export fzDocumentOpenWithStreamFnD625D461
func fzDocumentOpenWithStreamFnD625D461(cctx *C.fz_context, cstream *C.fz_stream) *C.fz_document {
	if fzDocumentOpenWithStreamFnD625D461Func != nil {
		ctxd625d461 := NewFzContextRef(unsafe.Pointer(cctx))
		streamd625d461 := NewFzStreamRef(unsafe.Pointer(cstream))
		retd625d461 := fzDocumentOpenWithStreamFnD625D461Func(ctxd625d461, streamd625d461)
		ret, _ := (*C.fz_document)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&retd625d461)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentOpenWithStreamFnD625D461Func FzDocumentOpenWithStreamFn

func (x FzDocumentRecognizeFn) PassRef() (ref *C.fz_document_recognize_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentRecognizeFn37E0CEF4Func == nil {
		fzDocumentRecognizeFn37E0CEF4Func = x
	}
	return (*C.fz_document_recognize_fn)(C.fz_document_recognize_fn_37e0cef4), nil
}

func NewFzDocumentRecognizeFnRef(ref unsafe.Pointer) *FzDocumentRecognizeFn {
	return (*FzDocumentRecognizeFn)(ref)
}

//export fzDocumentRecognizeFn37E0CEF4
func fzDocumentRecognizeFn37E0CEF4(cctx *C.fz_context, cmagic *C.char) C.int {
	if fzDocumentRecognizeFn37E0CEF4Func != nil {
		ctx37e0cef4 := NewFzContextRef(unsafe.Pointer(cctx))
		magic37e0cef4 := packPCharString(cmagic)
		ret37e0cef4 := fzDocumentRecognizeFn37E0CEF4Func(ctx37e0cef4, magic37e0cef4)
		ret, _ := (C.int)(ret37e0cef4), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentRecognizeFn37E0CEF4Func FzDocumentRecognizeFn

// Ref returns a reference to C object as it is.
func (x *FzDocumentWriter) Ref() *C.fz_document_writer {
	if x == nil {
		return nil
	}
	return (*C.fz_document_writer)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzDocumentWriter) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzDocumentWriterRef converts the C object reference into a raw struct reference without wrapping.
func NewFzDocumentWriterRef(ref unsafe.Pointer) *FzDocumentWriter {
	return (*FzDocumentWriter)(ref)
}

// NewFzDocumentWriter allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzDocumentWriter() *FzDocumentWriter {
	return (*FzDocumentWriter)(allocFzDocumentWriterMemory(1))
}

// allocFzDocumentWriterMemory allocates memory for type C.fz_document_writer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzDocumentWriterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzDocumentWriterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzDocumentWriterValue = unsafe.Sizeof([1]C.fz_document_writer{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzDocumentWriter) PassRef() *C.fz_document_writer {
	if x == nil {
		x = (*FzDocumentWriter)(allocFzDocumentWriterMemory(1))
	}
	return (*C.fz_document_writer)(unsafe.Pointer(x))
}

func (x FzDocumentWriterBeginPageFn) PassRef() (ref *C.fz_document_writer_begin_page_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentWriterBeginPageFn67284625Func == nil {
		fzDocumentWriterBeginPageFn67284625Func = x
	}
	return (*C.fz_document_writer_begin_page_fn)(C.fz_document_writer_begin_page_fn_67284625), nil
}

func NewFzDocumentWriterBeginPageFnRef(ref unsafe.Pointer) *FzDocumentWriterBeginPageFn {
	return (*FzDocumentWriterBeginPageFn)(ref)
}

//export fzDocumentWriterBeginPageFn67284625
func fzDocumentWriterBeginPageFn67284625(cctx *C.fz_context, cwri *C.fz_document_writer, cmediabox *C.fz_rect) *C.fz_device {
	if fzDocumentWriterBeginPageFn67284625Func != nil {
		ctx67284625 := NewFzContextRef(unsafe.Pointer(cctx))
		wri67284625 := NewFzDocumentWriterRef(unsafe.Pointer(cwri))
		var mediabox67284625 []FzRect
		packSFzRect(mediabox67284625, cmediabox)
		ret67284625 := fzDocumentWriterBeginPageFn67284625Func(ctx67284625, wri67284625, mediabox67284625)
		ret, _ := (*C.fz_device)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ret67284625)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentWriterBeginPageFn67284625Func FzDocumentWriterBeginPageFn

func (x FzDocumentWriterEndPageFn) PassRef() (ref *C.fz_document_writer_end_page_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentWriterEndPageFnC982F24FFunc == nil {
		fzDocumentWriterEndPageFnC982F24FFunc = x
	}
	return (*C.fz_document_writer_end_page_fn)(C.fz_document_writer_end_page_fn_c982f24f), nil
}

func NewFzDocumentWriterEndPageFnRef(ref unsafe.Pointer) *FzDocumentWriterEndPageFn {
	return (*FzDocumentWriterEndPageFn)(ref)
}

//export fzDocumentWriterEndPageFnC982F24F
func fzDocumentWriterEndPageFnC982F24F(cctx *C.fz_context, cwri *C.fz_document_writer, cdev *C.fz_device) {
	if fzDocumentWriterEndPageFnC982F24FFunc != nil {
		ctxc982f24f := NewFzContextRef(unsafe.Pointer(cctx))
		wric982f24f := NewFzDocumentWriterRef(unsafe.Pointer(cwri))
		var devc982f24f []FzDevice
		packSFzDevice(devc982f24f, cdev)
		fzDocumentWriterEndPageFnC982F24FFunc(ctxc982f24f, wric982f24f, devc982f24f)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentWriterEndPageFnC982F24FFunc FzDocumentWriterEndPageFn

func (x FzDocumentWriterCloseWriterFn) PassRef() (ref *C.fz_document_writer_close_writer_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentWriterCloseWriterFn383BAADDFunc == nil {
		fzDocumentWriterCloseWriterFn383BAADDFunc = x
	}
	return (*C.fz_document_writer_close_writer_fn)(C.fz_document_writer_close_writer_fn_383baadd), nil
}

func NewFzDocumentWriterCloseWriterFnRef(ref unsafe.Pointer) *FzDocumentWriterCloseWriterFn {
	return (*FzDocumentWriterCloseWriterFn)(ref)
}

//export fzDocumentWriterCloseWriterFn383BAADD
func fzDocumentWriterCloseWriterFn383BAADD(cctx *C.fz_context, cwri *C.fz_document_writer) {
	if fzDocumentWriterCloseWriterFn383BAADDFunc != nil {
		ctx383baadd := NewFzContextRef(unsafe.Pointer(cctx))
		wri383baadd := NewFzDocumentWriterRef(unsafe.Pointer(cwri))
		fzDocumentWriterCloseWriterFn383BAADDFunc(ctx383baadd, wri383baadd)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentWriterCloseWriterFn383BAADDFunc FzDocumentWriterCloseWriterFn

func (x FzDocumentWriterDropWriterFn) PassRef() (ref *C.fz_document_writer_drop_writer_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDocumentWriterDropWriterFn2AC1EB31Func == nil {
		fzDocumentWriterDropWriterFn2AC1EB31Func = x
	}
	return (*C.fz_document_writer_drop_writer_fn)(C.fz_document_writer_drop_writer_fn_2ac1eb31), nil
}

func NewFzDocumentWriterDropWriterFnRef(ref unsafe.Pointer) *FzDocumentWriterDropWriterFn {
	return (*FzDocumentWriterDropWriterFn)(ref)
}

//export fzDocumentWriterDropWriterFn2AC1EB31
func fzDocumentWriterDropWriterFn2AC1EB31(cctx *C.fz_context, cwri *C.fz_document_writer) {
	if fzDocumentWriterDropWriterFn2AC1EB31Func != nil {
		ctx2ac1eb31 := NewFzContextRef(unsafe.Pointer(cctx))
		wri2ac1eb31 := NewFzDocumentWriterRef(unsafe.Pointer(cwri))
		fzDocumentWriterDropWriterFn2AC1EB31Func(ctx2ac1eb31, wri2ac1eb31)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzDocumentWriterDropWriterFn2AC1EB31Func FzDocumentWriterDropWriterFn

// Ref returns a reference to C object as it is.
func (x *FzBandWriter) Ref() *C.fz_band_writer {
	if x == nil {
		return nil
	}
	return (*C.fz_band_writer)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzBandWriter) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzBandWriterRef converts the C object reference into a raw struct reference without wrapping.
func NewFzBandWriterRef(ref unsafe.Pointer) *FzBandWriter {
	return (*FzBandWriter)(ref)
}

// NewFzBandWriter allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzBandWriter() *FzBandWriter {
	return (*FzBandWriter)(allocFzBandWriterMemory(1))
}

// allocFzBandWriterMemory allocates memory for type C.fz_band_writer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzBandWriterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzBandWriterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzBandWriterValue = unsafe.Sizeof([1]C.fz_band_writer{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzBandWriter) PassRef() *C.fz_band_writer {
	if x == nil {
		x = (*FzBandWriter)(allocFzBandWriterMemory(1))
	}
	return (*C.fz_band_writer)(unsafe.Pointer(x))
}

func (x FzWriteHeaderFn) PassRef() (ref *C.fz_write_header_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzWriteHeaderFn60D0D497Func == nil {
		fzWriteHeaderFn60D0D497Func = x
	}
	return (*C.fz_write_header_fn)(C.fz_write_header_fn_60d0d497), nil
}

func NewFzWriteHeaderFnRef(ref unsafe.Pointer) *FzWriteHeaderFn {
	return (*FzWriteHeaderFn)(ref)
}

//export fzWriteHeaderFn60D0D497
func fzWriteHeaderFn60D0D497(cctx *C.fz_context, cwriter *C.fz_band_writer, ccs *C.fz_colorspace) {
	if fzWriteHeaderFn60D0D497Func != nil {
		ctx60d0d497 := NewFzContextRef(unsafe.Pointer(cctx))
		writer60d0d497 := NewFzBandWriterRef(unsafe.Pointer(cwriter))
		var cs60d0d497 []FzColorspace
		hxf21690b := (*sliceHeader)(unsafe.Pointer(&cs60d0d497))
		hxf21690b.Data = uintptr(unsafe.Pointer(ccs))
		hxf21690b.Cap = 0x7fffffff
		// hxf21690b.Len = ?

		fzWriteHeaderFn60D0D497Func(ctx60d0d497, writer60d0d497, cs60d0d497)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzWriteHeaderFn60D0D497Func FzWriteHeaderFn

// packPUcharString creates a Go string backed by *C.uchar and avoids copying.
func packPUcharString(p *C.uchar) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

func (x FzWriteBandFn) PassRef() (ref *C.fz_write_band_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzWriteBandFn64127B36Func == nil {
		fzWriteBandFn64127B36Func = x
	}
	return (*C.fz_write_band_fn)(C.fz_write_band_fn_64127b36), nil
}

func NewFzWriteBandFnRef(ref unsafe.Pointer) *FzWriteBandFn {
	return (*FzWriteBandFn)(ref)
}

//export fzWriteBandFn64127B36
func fzWriteBandFn64127B36(cctx *C.fz_context, cwriter *C.fz_band_writer, cstride C.int, cbandStart C.int, cbandHeight C.int, csamples *C.uchar) {
	if fzWriteBandFn64127B36Func != nil {
		ctx64127b36 := NewFzContextRef(unsafe.Pointer(cctx))
		writer64127b36 := NewFzBandWriterRef(unsafe.Pointer(cwriter))
		stride64127b36 := (int32)(cstride)
		bandStart64127b36 := (int32)(cbandStart)
		bandHeight64127b36 := (int32)(cbandHeight)
		samples64127b36 := packPUcharString(csamples)
		fzWriteBandFn64127B36Func(ctx64127b36, writer64127b36, stride64127b36, bandStart64127b36, bandHeight64127b36, samples64127b36)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzWriteBandFn64127B36Func FzWriteBandFn

func (x FzWriteTrailerFn) PassRef() (ref *C.fz_write_trailer_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzWriteTrailerFnC6136351Func == nil {
		fzWriteTrailerFnC6136351Func = x
	}
	return (*C.fz_write_trailer_fn)(C.fz_write_trailer_fn_c6136351), nil
}

func NewFzWriteTrailerFnRef(ref unsafe.Pointer) *FzWriteTrailerFn {
	return (*FzWriteTrailerFn)(ref)
}

//export fzWriteTrailerFnC6136351
func fzWriteTrailerFnC6136351(cctx *C.fz_context, cwriter *C.fz_band_writer) {
	if fzWriteTrailerFnC6136351Func != nil {
		ctxc6136351 := NewFzContextRef(unsafe.Pointer(cctx))
		writerc6136351 := NewFzBandWriterRef(unsafe.Pointer(cwriter))
		fzWriteTrailerFnC6136351Func(ctxc6136351, writerc6136351)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzWriteTrailerFnC6136351Func FzWriteTrailerFn

func (x FzDropBandWriterFn) PassRef() (ref *C.fz_drop_band_writer_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if fzDropBandWriterFn6B3F033FFunc == nil {
		fzDropBandWriterFn6B3F033FFunc = x
	}
	return (*C.fz_drop_band_writer_fn)(C.fz_drop_band_writer_fn_6b3f033f), nil
}

func NewFzDropBandWriterFnRef(ref unsafe.Pointer) *FzDropBandWriterFn {
	return (*FzDropBandWriterFn)(ref)
}

//export fzDropBandWriterFn6B3F033F
func fzDropBandWriterFn6B3F033F(cctx *C.fz_context, cwriter *C.fz_band_writer) {
	if fzDropBandWriterFn6B3F033FFunc != nil {
		ctx6b3f033f := NewFzContextRef(unsafe.Pointer(cctx))
		writer6b3f033f := NewFzBandWriterRef(unsafe.Pointer(cwriter))
		fzDropBandWriterFn6B3F033FFunc(ctx6b3f033f, writer6b3f033f)
		return
	}
	panic("callback func has not been set (race?)")
}

var fzDropBandWriterFn6B3F033FFunc FzDropBandWriterFn

// Ref returns a reference to C object as it is.
func (x *FzPwgOptions) Ref() *C.fz_pwg_options {
	if x == nil {
		return nil
	}
	return (*C.fz_pwg_options)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzPwgOptions) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzPwgOptionsRef converts the C object reference into a raw struct reference without wrapping.
func NewFzPwgOptionsRef(ref unsafe.Pointer) *FzPwgOptions {
	return (*FzPwgOptions)(ref)
}

// NewFzPwgOptions allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzPwgOptions() *FzPwgOptions {
	return (*FzPwgOptions)(allocFzPwgOptionsMemory(1))
}

// allocFzPwgOptionsMemory allocates memory for type C.fz_pwg_options in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzPwgOptionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzPwgOptionsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzPwgOptionsValue = unsafe.Sizeof([1]C.fz_pwg_options{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzPwgOptions) PassRef() *C.fz_pwg_options {
	if x == nil {
		x = (*FzPwgOptions)(allocFzPwgOptionsMemory(1))
	}
	return (*C.fz_pwg_options)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzPclOptions) Ref() *C.fz_pcl_options {
	if x == nil {
		return nil
	}
	return (*C.fz_pcl_options)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzPclOptions) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzPclOptionsRef converts the C object reference into a raw struct reference without wrapping.
func NewFzPclOptionsRef(ref unsafe.Pointer) *FzPclOptions {
	return (*FzPclOptions)(ref)
}

// NewFzPclOptions allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzPclOptions() *FzPclOptions {
	return (*FzPclOptions)(allocFzPclOptionsMemory(1))
}

// allocFzPclOptionsMemory allocates memory for type C.fz_pcl_options in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzPclOptionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzPclOptionsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzPclOptionsValue = unsafe.Sizeof([1]C.fz_pcl_options{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzPclOptions) PassRef() *C.fz_pcl_options {
	if x == nil {
		x = (*FzPclOptions)(allocFzPclOptionsMemory(1))
	}
	return (*C.fz_pcl_options)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FzPclmOptions) Ref() *C.fz_pclm_options {
	if x == nil {
		return nil
	}
	return (*C.fz_pclm_options)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FzPclmOptions) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFzPclmOptionsRef converts the C object reference into a raw struct reference without wrapping.
func NewFzPclmOptionsRef(ref unsafe.Pointer) *FzPclmOptions {
	return (*FzPclmOptions)(ref)
}

// NewFzPclmOptions allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFzPclmOptions() *FzPclmOptions {
	return (*FzPclmOptions)(allocFzPclmOptionsMemory(1))
}

// allocFzPclmOptionsMemory allocates memory for type C.fz_pclm_options in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFzPclmOptionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFzPclmOptionsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFzPclmOptionsValue = unsafe.Sizeof([1]C.fz_pclm_options{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FzPclmOptions) PassRef() *C.fz_pclm_options {
	if x == nil {
		x = (*FzPclmOptions)(allocFzPclmOptionsMemory(1))
	}
	return (*C.fz_pclm_options)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFDocument) Ref() *C.pdf_document {
	if x == nil {
		return nil
	}
	return (*C.pdf_document)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFDocument) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFDocumentRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFDocumentRef(ref unsafe.Pointer) *PDFDocument {
	return (*PDFDocument)(ref)
}

// NewPDFDocument allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFDocument() *PDFDocument {
	return (*PDFDocument)(allocPDFDocumentMemory(1))
}

// allocPDFDocumentMemory allocates memory for type C.pdf_document in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFDocumentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFDocumentValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFDocumentValue = unsafe.Sizeof([1]C.pdf_document{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFDocument) PassRef() *C.pdf_document {
	if x == nil {
		x = (*PDFDocument)(allocPDFDocumentMemory(1))
	}
	return (*C.pdf_document)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFObj) Ref() *C.pdf_obj {
	if x == nil {
		return nil
	}
	return (*C.pdf_obj)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFObj) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFObjRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFObjRef(ref unsafe.Pointer) *PDFObj {
	return (*PDFObj)(ref)
}

// NewPDFObj allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFObj() *PDFObj {
	return (*PDFObj)(allocPDFObjMemory(1))
}

// allocPDFObjMemory allocates memory for type C.pdf_obj in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFObjMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFObjValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFObjValue = unsafe.Sizeof([1]C.pdf_obj{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFObj) PassRef() *C.pdf_obj {
	if x == nil {
		x = (*PDFObj)(allocPDFObjMemory(1))
	}
	return (*C.pdf_obj)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFLexbuf) Ref() *C.pdf_lexbuf {
	if x == nil {
		return nil
	}
	return (*C.pdf_lexbuf)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFLexbuf) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFLexbufRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFLexbufRef(ref unsafe.Pointer) *PDFLexbuf {
	return (*PDFLexbuf)(ref)
}

// NewPDFLexbuf allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFLexbuf() *PDFLexbuf {
	return (*PDFLexbuf)(allocPDFLexbufMemory(1))
}

// allocPDFLexbufMemory allocates memory for type C.pdf_lexbuf in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFLexbufMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFLexbufValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFLexbufValue = unsafe.Sizeof([1]C.pdf_lexbuf{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFLexbuf) PassRef() *C.pdf_lexbuf {
	if x == nil {
		x = (*PDFLexbuf)(allocPDFLexbufMemory(1))
	}
	return (*C.pdf_lexbuf)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFLexbufLarge) Ref() *C.pdf_lexbuf_large {
	if x == nil {
		return nil
	}
	return (*C.pdf_lexbuf_large)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFLexbufLarge) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFLexbufLargeRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFLexbufLargeRef(ref unsafe.Pointer) *PDFLexbufLarge {
	return (*PDFLexbufLarge)(ref)
}

// NewPDFLexbufLarge allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFLexbufLarge() *PDFLexbufLarge {
	return (*PDFLexbufLarge)(allocPDFLexbufLargeMemory(1))
}

// allocPDFLexbufLargeMemory allocates memory for type C.pdf_lexbuf_large in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFLexbufLargeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFLexbufLargeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFLexbufLargeValue = unsafe.Sizeof([1]C.pdf_lexbuf_large{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFLexbufLarge) PassRef() *C.pdf_lexbuf_large {
	if x == nil {
		x = (*PDFLexbufLarge)(allocPDFLexbufLargeMemory(1))
	}
	return (*C.pdf_lexbuf_large)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFXref) Ref() *C.pdf_xref {
	if x == nil {
		return nil
	}
	return (*C.pdf_xref)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFXref) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFXrefRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFXrefRef(ref unsafe.Pointer) *PDFXref {
	return (*PDFXref)(ref)
}

// NewPDFXref allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFXref() *PDFXref {
	return (*PDFXref)(allocPDFXrefMemory(1))
}

// allocPDFXrefMemory allocates memory for type C.pdf_xref in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFXrefMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFXrefValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFXrefValue = unsafe.Sizeof([1]C.pdf_xref{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFXref) PassRef() *C.pdf_xref {
	if x == nil {
		x = (*PDFXref)(allocPDFXrefMemory(1))
	}
	return (*C.pdf_xref)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFCrypt) Ref() *C.pdf_crypt {
	if x == nil {
		return nil
	}
	return (*C.pdf_crypt)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFCrypt) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFCryptRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFCryptRef(ref unsafe.Pointer) *PDFCrypt {
	return (*PDFCrypt)(ref)
}

// NewPDFCrypt allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFCrypt() *PDFCrypt {
	return (*PDFCrypt)(allocPDFCryptMemory(1))
}

// allocPDFCryptMemory allocates memory for type C.pdf_crypt in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFCryptMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFCryptValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFCryptValue = unsafe.Sizeof([1]C.pdf_crypt{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFCrypt) PassRef() *C.pdf_crypt {
	if x == nil {
		x = (*PDFCrypt)(allocPDFCryptMemory(1))
	}
	return (*C.pdf_crypt)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFOcgDescriptor) Ref() *C.pdf_ocg_descriptor {
	if x == nil {
		return nil
	}
	return (*C.pdf_ocg_descriptor)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFOcgDescriptor) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFOcgDescriptorRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFOcgDescriptorRef(ref unsafe.Pointer) *PDFOcgDescriptor {
	return (*PDFOcgDescriptor)(ref)
}

// NewPDFOcgDescriptor allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFOcgDescriptor() *PDFOcgDescriptor {
	return (*PDFOcgDescriptor)(allocPDFOcgDescriptorMemory(1))
}

// allocPDFOcgDescriptorMemory allocates memory for type C.pdf_ocg_descriptor in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFOcgDescriptorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFOcgDescriptorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFOcgDescriptorValue = unsafe.Sizeof([1]C.pdf_ocg_descriptor{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFOcgDescriptor) PassRef() *C.pdf_ocg_descriptor {
	if x == nil {
		x = (*PDFOcgDescriptor)(allocPDFOcgDescriptorMemory(1))
	}
	return (*C.pdf_ocg_descriptor)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFPortfolio) Ref() *C.pdf_portfolio {
	if x == nil {
		return nil
	}
	return (*C.pdf_portfolio)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFPortfolio) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFPortfolioRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFPortfolioRef(ref unsafe.Pointer) *PDFPortfolio {
	return (*PDFPortfolio)(ref)
}

// NewPDFPortfolio allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFPortfolio() *PDFPortfolio {
	return (*PDFPortfolio)(allocPDFPortfolioMemory(1))
}

// allocPDFPortfolioMemory allocates memory for type C.pdf_portfolio in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFPortfolioMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFPortfolioValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFPortfolioValue = unsafe.Sizeof([1]C.pdf_portfolio{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFPortfolio) PassRef() *C.pdf_portfolio {
	if x == nil {
		x = (*PDFPortfolio)(allocPDFPortfolioMemory(1))
	}
	return (*C.pdf_portfolio)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFPage) Ref() *C.pdf_page {
	if x == nil {
		return nil
	}
	return (*C.pdf_page)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFPage) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFPageRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFPageRef(ref unsafe.Pointer) *PDFPage {
	return (*PDFPage)(ref)
}

// NewPDFPage allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFPage() *PDFPage {
	return (*PDFPage)(allocPDFPageMemory(1))
}

// allocPDFPageMemory allocates memory for type C.pdf_page in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFPageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFPageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFPageValue = unsafe.Sizeof([1]C.pdf_page{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFPage) PassRef() *C.pdf_page {
	if x == nil {
		x = (*PDFPage)(allocPDFPageMemory(1))
	}
	return (*C.pdf_page)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFAnnot) Ref() *C.pdf_annot {
	if x == nil {
		return nil
	}
	return (*C.pdf_annot)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFAnnot) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFAnnotRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFAnnotRef(ref unsafe.Pointer) *PDFAnnot {
	return (*PDFAnnot)(ref)
}

// NewPDFAnnot allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFAnnot() *PDFAnnot {
	return (*PDFAnnot)(allocPDFAnnotMemory(1))
}

// allocPDFAnnotMemory allocates memory for type C.pdf_annot in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFAnnotMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFAnnotValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFAnnotValue = unsafe.Sizeof([1]C.pdf_annot{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFAnnot) PassRef() *C.pdf_annot {
	if x == nil {
		x = (*PDFAnnot)(allocPDFAnnotMemory(1))
	}
	return (*C.pdf_annot)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFWidget) Ref() *C.pdf_widget {
	if x == nil {
		return nil
	}
	return (*C.pdf_widget)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFWidget) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFWidgetRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFWidgetRef(ref unsafe.Pointer) *PDFWidget {
	return (*PDFWidget)(ref)
}

// NewPDFWidget allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFWidget() *PDFWidget {
	return (*PDFWidget)(allocPDFWidgetMemory(1))
}

// allocPDFWidgetMemory allocates memory for type C.pdf_widget in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFWidgetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFWidgetValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFWidgetValue = unsafe.Sizeof([1]C.pdf_widget{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFWidget) PassRef() *C.pdf_widget {
	if x == nil {
		x = (*PDFWidget)(allocPDFWidgetMemory(1))
	}
	return (*C.pdf_widget)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFHotspot) Ref() *C.pdf_hotspot {
	if x == nil {
		return nil
	}
	return (*C.pdf_hotspot)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFHotspot) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFHotspotRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFHotspotRef(ref unsafe.Pointer) *PDFHotspot {
	return (*PDFHotspot)(ref)
}

// NewPDFHotspot allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFHotspot() *PDFHotspot {
	return (*PDFHotspot)(allocPDFHotspotMemory(1))
}

// allocPDFHotspotMemory allocates memory for type C.pdf_hotspot in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFHotspotMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFHotspotValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFHotspotValue = unsafe.Sizeof([1]C.pdf_hotspot{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFHotspot) PassRef() *C.pdf_hotspot {
	if x == nil {
		x = (*PDFHotspot)(allocPDFHotspotMemory(1))
	}
	return (*C.pdf_hotspot)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFJs) Ref() *C.pdf_js {
	if x == nil {
		return nil
	}
	return (*C.pdf_js)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFJs) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFJsRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFJsRef(ref unsafe.Pointer) *PDFJs {
	return (*PDFJs)(ref)
}

// NewPDFJs allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFJs() *PDFJs {
	return (*PDFJs)(allocPDFJsMemory(1))
}

// allocPDFJsMemory allocates memory for type C.pdf_js in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFJsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFJsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFJsValue = unsafe.Sizeof([1]C.pdf_js{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFJs) PassRef() *C.pdf_js {
	if x == nil {
		x = (*PDFJs)(allocPDFJsMemory(1))
	}
	return (*C.pdf_js)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFDocEvent) Ref() *C.pdf_doc_event {
	if x == nil {
		return nil
	}
	return (*C.pdf_doc_event)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFDocEvent) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFDocEventRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFDocEventRef(ref unsafe.Pointer) *PDFDocEvent {
	return (*PDFDocEvent)(ref)
}

// NewPDFDocEvent allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFDocEvent() *PDFDocEvent {
	return (*PDFDocEvent)(allocPDFDocEventMemory(1))
}

// allocPDFDocEventMemory allocates memory for type C.pdf_doc_event in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFDocEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFDocEventValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFDocEventValue = unsafe.Sizeof([1]C.pdf_doc_event{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFDocEvent) PassRef() *C.pdf_doc_event {
	if x == nil {
		x = (*PDFDocEvent)(allocPDFDocEventMemory(1))
	}
	return (*C.pdf_doc_event)(unsafe.Pointer(x))
}

// packSPDFDocEvent reads sliced Go data structure out from plain C format.
func packSPDFDocEvent(v []PDFDocEvent, ptr0 *C.pdf_doc_event) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPDFDocEventValue]C.pdf_doc_event)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPDFDocEventRef(unsafe.Pointer(&ptr1))
	}
}

func (x PDFDocEventCb) PassRef() (ref *C.pdf_doc_event_cb, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pDFDocEventCbD9608017Func == nil {
		pDFDocEventCbD9608017Func = x
	}
	return (*C.pdf_doc_event_cb)(C.pdf_doc_event_cb_d9608017), nil
}

func NewPDFDocEventCbRef(ref unsafe.Pointer) *PDFDocEventCb {
	return (*PDFDocEventCb)(ref)
}

//export pDFDocEventCbD9608017
func pDFDocEventCbD9608017(cctx *C.fz_context, cdoc *C.pdf_document, cevent *C.pdf_doc_event, cdata unsafe.Pointer) {
	if pDFDocEventCbD9608017Func != nil {
		ctxd9608017 := NewFzContextRef(unsafe.Pointer(cctx))
		docd9608017 := NewPDFDocumentRef(unsafe.Pointer(cdoc))
		var eventd9608017 []PDFDocEvent
		packSPDFDocEvent(eventd9608017, cevent)
		datad9608017 := (unsafe.Pointer)(unsafe.Pointer(cdata))
		pDFDocEventCbD9608017Func(ctxd9608017, docd9608017, eventd9608017, datad9608017)
		return
	}
	panic("callback func has not been set (race?)")
}

var pDFDocEventCbD9608017Func PDFDocEventCb

// Ref returns a reference to C object as it is.
func (x *PDFLayerConfig) Ref() *C.pdf_layer_config {
	if x == nil {
		return nil
	}
	return (*C.pdf_layer_config)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFLayerConfig) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFLayerConfigRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFLayerConfigRef(ref unsafe.Pointer) *PDFLayerConfig {
	return (*PDFLayerConfig)(ref)
}

// NewPDFLayerConfig allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFLayerConfig() *PDFLayerConfig {
	return (*PDFLayerConfig)(allocPDFLayerConfigMemory(1))
}

// allocPDFLayerConfigMemory allocates memory for type C.pdf_layer_config in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFLayerConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFLayerConfigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFLayerConfigValue = unsafe.Sizeof([1]C.pdf_layer_config{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFLayerConfig) PassRef() *C.pdf_layer_config {
	if x == nil {
		x = (*PDFLayerConfig)(allocPDFLayerConfigMemory(1))
	}
	return (*C.pdf_layer_config)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFLayerConfigUi) Ref() *C.pdf_layer_config_ui {
	if x == nil {
		return nil
	}
	return (*C.pdf_layer_config_ui)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFLayerConfigUi) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFLayerConfigUiRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFLayerConfigUiRef(ref unsafe.Pointer) *PDFLayerConfigUi {
	return (*PDFLayerConfigUi)(ref)
}

// NewPDFLayerConfigUi allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFLayerConfigUi() *PDFLayerConfigUi {
	return (*PDFLayerConfigUi)(allocPDFLayerConfigUiMemory(1))
}

// allocPDFLayerConfigUiMemory allocates memory for type C.pdf_layer_config_ui in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFLayerConfigUiMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFLayerConfigUiValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFLayerConfigUiValue = unsafe.Sizeof([1]C.pdf_layer_config_ui{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFLayerConfigUi) PassRef() *C.pdf_layer_config_ui {
	if x == nil {
		x = (*PDFLayerConfigUi)(allocPDFLayerConfigUiMemory(1))
	}
	return (*C.pdf_layer_config_ui)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFPortfolioSchema) Ref() *C.pdf_portfolio_schema {
	if x == nil {
		return nil
	}
	return (*C.pdf_portfolio_schema)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFPortfolioSchema) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFPortfolioSchemaRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFPortfolioSchemaRef(ref unsafe.Pointer) *PDFPortfolioSchema {
	return (*PDFPortfolioSchema)(ref)
}

// NewPDFPortfolioSchema allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFPortfolioSchema() *PDFPortfolioSchema {
	return (*PDFPortfolioSchema)(allocPDFPortfolioSchemaMemory(1))
}

// allocPDFPortfolioSchemaMemory allocates memory for type C.pdf_portfolio_schema in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFPortfolioSchemaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFPortfolioSchemaValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFPortfolioSchemaValue = unsafe.Sizeof([1]C.pdf_portfolio_schema{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFPortfolioSchema) PassRef() *C.pdf_portfolio_schema {
	if x == nil {
		x = (*PDFPortfolioSchema)(allocPDFPortfolioSchemaMemory(1))
	}
	return (*C.pdf_portfolio_schema)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFSigner) Ref() *C.pdf_signer {
	if x == nil {
		return nil
	}
	return (*C.pdf_signer)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFSigner) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFSignerRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFSignerRef(ref unsafe.Pointer) *PDFSigner {
	return (*PDFSigner)(ref)
}

// NewPDFSigner allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFSigner() *PDFSigner {
	return (*PDFSigner)(allocPDFSignerMemory(1))
}

// allocPDFSignerMemory allocates memory for type C.pdf_signer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFSignerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFSignerValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFSignerValue = unsafe.Sizeof([1]C.pdf_signer{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFSigner) PassRef() *C.pdf_signer {
	if x == nil {
		x = (*PDFSigner)(allocPDFSignerMemory(1))
	}
	return (*C.pdf_signer)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFUnsavedSig) Ref() *C.pdf_unsaved_sig {
	if x == nil {
		return nil
	}
	return (*C.pdf_unsaved_sig)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFUnsavedSig) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFUnsavedSigRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFUnsavedSigRef(ref unsafe.Pointer) *PDFUnsavedSig {
	return (*PDFUnsavedSig)(ref)
}

// NewPDFUnsavedSig allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFUnsavedSig() *PDFUnsavedSig {
	return (*PDFUnsavedSig)(allocPDFUnsavedSigMemory(1))
}

// allocPDFUnsavedSigMemory allocates memory for type C.pdf_unsaved_sig in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFUnsavedSigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFUnsavedSigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFUnsavedSigValue = unsafe.Sizeof([1]C.pdf_unsaved_sig{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFUnsavedSig) PassRef() *C.pdf_unsaved_sig {
	if x == nil {
		x = (*PDFUnsavedSig)(allocPDFUnsavedSigMemory(1))
	}
	return (*C.pdf_unsaved_sig)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFRevPageMap) Ref() *C.pdf_rev_page_map {
	if x == nil {
		return nil
	}
	return (*C.pdf_rev_page_map)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFRevPageMap) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFRevPageMapRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFRevPageMapRef(ref unsafe.Pointer) *PDFRevPageMap {
	return (*PDFRevPageMap)(ref)
}

// NewPDFRevPageMap allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFRevPageMap() *PDFRevPageMap {
	return (*PDFRevPageMap)(allocPDFRevPageMapMemory(1))
}

// allocPDFRevPageMapMemory allocates memory for type C.pdf_rev_page_map in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFRevPageMapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFRevPageMapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFRevPageMapValue = unsafe.Sizeof([1]C.pdf_rev_page_map{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFRevPageMap) PassRef() *C.pdf_rev_page_map {
	if x == nil {
		x = (*PDFRevPageMap)(allocPDFRevPageMapMemory(1))
	}
	return (*C.pdf_rev_page_map)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFGraftMap) Ref() *C.pdf_graft_map {
	if x == nil {
		return nil
	}
	return (*C.pdf_graft_map)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFGraftMap) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFGraftMapRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFGraftMapRef(ref unsafe.Pointer) *PDFGraftMap {
	return (*PDFGraftMap)(ref)
}

// NewPDFGraftMap allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFGraftMap() *PDFGraftMap {
	return (*PDFGraftMap)(allocPDFGraftMapMemory(1))
}

// allocPDFGraftMapMemory allocates memory for type C.pdf_graft_map in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFGraftMapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFGraftMapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFGraftMapValue = unsafe.Sizeof([1]C.pdf_graft_map{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFGraftMap) PassRef() *C.pdf_graft_map {
	if x == nil {
		x = (*PDFGraftMap)(allocPDFGraftMapMemory(1))
	}
	return (*C.pdf_graft_map)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFWriteOptions) Ref() *C.pdf_write_options {
	if x == nil {
		return nil
	}
	return (*C.pdf_write_options)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFWriteOptions) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFWriteOptionsRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFWriteOptionsRef(ref unsafe.Pointer) *PDFWriteOptions {
	return (*PDFWriteOptions)(ref)
}

// NewPDFWriteOptions allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFWriteOptions() *PDFWriteOptions {
	return (*PDFWriteOptions)(allocPDFWriteOptionsMemory(1))
}

// allocPDFWriteOptionsMemory allocates memory for type C.pdf_write_options in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFWriteOptionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFWriteOptionsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFWriteOptionsValue = unsafe.Sizeof([1]C.pdf_write_options{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFWriteOptions) PassRef() *C.pdf_write_options {
	if x == nil {
		x = (*PDFWriteOptions)(allocPDFWriteOptionsMemory(1))
	}
	return (*C.pdf_write_options)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFXrefEntry) Ref() *C.pdf_xref_entry {
	if x == nil {
		return nil
	}
	return (*C.pdf_xref_entry)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFXrefEntry) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFXrefEntryRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFXrefEntryRef(ref unsafe.Pointer) *PDFXrefEntry {
	return (*PDFXrefEntry)(ref)
}

// NewPDFXrefEntry allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFXrefEntry() *PDFXrefEntry {
	return (*PDFXrefEntry)(allocPDFXrefEntryMemory(1))
}

// allocPDFXrefEntryMemory allocates memory for type C.pdf_xref_entry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFXrefEntryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFXrefEntryValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFXrefEntryValue = unsafe.Sizeof([1]C.pdf_xref_entry{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFXrefEntry) PassRef() *C.pdf_xref_entry {
	if x == nil {
		x = (*PDFXrefEntry)(allocPDFXrefEntryMemory(1))
	}
	return (*C.pdf_xref_entry)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFXrefSubsec) Ref() *C.pdf_xref_subsec {
	if x == nil {
		return nil
	}
	return (*C.pdf_xref_subsec)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFXrefSubsec) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFXrefSubsecRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFXrefSubsecRef(ref unsafe.Pointer) *PDFXrefSubsec {
	return (*PDFXrefSubsec)(ref)
}

// NewPDFXrefSubsec allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFXrefSubsec() *PDFXrefSubsec {
	return (*PDFXrefSubsec)(allocPDFXrefSubsecMemory(1))
}

// allocPDFXrefSubsecMemory allocates memory for type C.pdf_xref_subsec in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFXrefSubsecMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFXrefSubsecValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFXrefSubsecValue = unsafe.Sizeof([1]C.pdf_xref_subsec{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFXrefSubsec) PassRef() *C.pdf_xref_subsec {
	if x == nil {
		x = (*PDFXrefSubsec)(allocPDFXrefSubsecMemory(1))
	}
	return (*C.pdf_xref_subsec)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFDesignatedName) Ref() *C.pdf_designated_name {
	if x == nil {
		return nil
	}
	return (*C.pdf_designated_name)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFDesignatedName) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFDesignatedNameRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFDesignatedNameRef(ref unsafe.Pointer) *PDFDesignatedName {
	return (*PDFDesignatedName)(ref)
}

// NewPDFDesignatedName allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFDesignatedName() *PDFDesignatedName {
	return (*PDFDesignatedName)(allocPDFDesignatedNameMemory(1))
}

// allocPDFDesignatedNameMemory allocates memory for type C.pdf_designated_name in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFDesignatedNameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFDesignatedNameValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFDesignatedNameValue = unsafe.Sizeof([1]C.pdf_designated_name{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFDesignatedName) PassRef() *C.pdf_designated_name {
	if x == nil {
		x = (*PDFDesignatedName)(allocPDFDesignatedNameMemory(1))
	}
	return (*C.pdf_designated_name)(unsafe.Pointer(x))
}

func (x PDFPageContentsProcessFn) PassRef() (ref *C.pdf_page_contents_process_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pDFPageContentsProcessFn7F179711Func == nil {
		pDFPageContentsProcessFn7F179711Func = x
	}
	return (*C.pdf_page_contents_process_fn)(C.pdf_page_contents_process_fn_7f179711), nil
}

func NewPDFPageContentsProcessFnRef(ref unsafe.Pointer) *PDFPageContentsProcessFn {
	return (*PDFPageContentsProcessFn)(ref)
}

//export pDFPageContentsProcessFn7F179711
func pDFPageContentsProcessFn7F179711(cctx *C.fz_context, cbuffer *C.fz_buffer, cres *C.pdf_obj, carg unsafe.Pointer) {
	if pDFPageContentsProcessFn7F179711Func != nil {
		ctx7f179711 := NewFzContextRef(unsafe.Pointer(cctx))
		buffer7f179711 := (*FzBuffer)(unsafe.Pointer(cbuffer))
		var res7f179711 []PDFObj
		hxf1231c9 := (*sliceHeader)(unsafe.Pointer(&res7f179711))
		hxf1231c9.Data = uintptr(unsafe.Pointer(cres))
		hxf1231c9.Cap = 0x7fffffff
		// hxf1231c9.Len = ?

		arg7f179711 := (unsafe.Pointer)(unsafe.Pointer(carg))
		pDFPageContentsProcessFn7F179711Func(ctx7f179711, buffer7f179711, res7f179711, arg7f179711)
		return
	}
	panic("callback func has not been set (race?)")
}

var pDFPageContentsProcessFn7F179711Func PDFPageContentsProcessFn

// Ref returns a reference to C object as it is.
func (x *PDFCsi) Ref() *C.pdf_csi {
	if x == nil {
		return nil
	}
	return (*C.pdf_csi)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFCsi) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFCsiRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFCsiRef(ref unsafe.Pointer) *PDFCsi {
	return (*PDFCsi)(ref)
}

// NewPDFCsi allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFCsi() *PDFCsi {
	return (*PDFCsi)(allocPDFCsiMemory(1))
}

// allocPDFCsiMemory allocates memory for type C.pdf_csi in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFCsiMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFCsiValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFCsiValue = unsafe.Sizeof([1]C.pdf_csi{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFCsi) PassRef() *C.pdf_csi {
	if x == nil {
		x = (*PDFCsi)(allocPDFCsiMemory(1))
	}
	return (*C.pdf_csi)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFGstate) Ref() *C.pdf_gstate {
	if x == nil {
		return nil
	}
	return (*C.pdf_gstate)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFGstate) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFGstateRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFGstateRef(ref unsafe.Pointer) *PDFGstate {
	return (*PDFGstate)(ref)
}

// NewPDFGstate allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFGstate() *PDFGstate {
	return (*PDFGstate)(allocPDFGstateMemory(1))
}

// allocPDFGstateMemory allocates memory for type C.pdf_gstate in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFGstateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFGstateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFGstateValue = unsafe.Sizeof([1]C.pdf_gstate{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFGstate) PassRef() *C.pdf_gstate {
	if x == nil {
		x = (*PDFGstate)(allocPDFGstateMemory(1))
	}
	return (*C.pdf_gstate)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFProcessor) Ref() *C.pdf_processor {
	if x == nil {
		return nil
	}
	return (*C.pdf_processor)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFProcessor) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFProcessorRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFProcessorRef(ref unsafe.Pointer) *PDFProcessor {
	return (*PDFProcessor)(ref)
}

// NewPDFProcessor allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFProcessor() *PDFProcessor {
	return (*PDFProcessor)(allocPDFProcessorMemory(1))
}

// allocPDFProcessorMemory allocates memory for type C.pdf_processor in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFProcessorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFProcessorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFProcessorValue = unsafe.Sizeof([1]C.pdf_processor{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFProcessor) PassRef() *C.pdf_processor {
	if x == nil {
		x = (*PDFProcessor)(allocPDFProcessorMemory(1))
	}
	return (*C.pdf_processor)(unsafe.Pointer(x))
}

func (x PDFTextFilterFn) PassRef() (ref *C.pdf_text_filter_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pDFTextFilterFn8833E584Func == nil {
		pDFTextFilterFn8833E584Func = x
	}
	return (*C.pdf_text_filter_fn)(C.pdf_text_filter_fn_8833e584), nil
}

func NewPDFTextFilterFnRef(ref unsafe.Pointer) *PDFTextFilterFn {
	return (*PDFTextFilterFn)(ref)
}

//export pDFTextFilterFn8833E584
func pDFTextFilterFn8833E584(cctx *C.fz_context, copaque unsafe.Pointer, cucsbuf *C.int, cucslen C.int, ctrm *C.fz_matrix, cbbox *C.fz_rect) C.int {
	if pDFTextFilterFn8833E584Func != nil {
		ctx8833e584 := NewFzContextRef(unsafe.Pointer(cctx))
		opaque8833e584 := (unsafe.Pointer)(unsafe.Pointer(copaque))
		var ucsbuf8833e584 []int32
		hxf04b15b := (*sliceHeader)(unsafe.Pointer(&ucsbuf8833e584))
		hxf04b15b.Data = uintptr(unsafe.Pointer(cucsbuf))
		hxf04b15b.Cap = 0x7fffffff
		// hxf04b15b.Len = ?

		ucslen8833e584 := (int32)(cucslen)
		var trm8833e584 []FzMatrix
		packSFzMatrix(trm8833e584, ctrm)
		var bbox8833e584 []FzRect
		packSFzRect(bbox8833e584, cbbox)
		ret8833e584 := pDFTextFilterFn8833E584Func(ctx8833e584, opaque8833e584, ucsbuf8833e584, ucslen8833e584, trm8833e584, bbox8833e584)
		ret, _ := (C.int)(ret8833e584), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pDFTextFilterFn8833E584Func PDFTextFilterFn

// packSPDFDocument reads sliced Go data structure out from plain C format.
func packSPDFDocument(v []PDFDocument, ptr0 *C.pdf_document) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPDFDocumentValue]C.pdf_document)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPDFDocumentRef(unsafe.Pointer(&ptr1))
	}
}

// packSPDFProcessor reads sliced Go data structure out from plain C format.
func packSPDFProcessor(v []PDFProcessor, ptr0 *C.pdf_processor) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPDFProcessorValue]C.pdf_processor)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPDFProcessorRef(unsafe.Pointer(&ptr1))
	}
}

func (x PDFAfterTextObjectFn) PassRef() (ref *C.pdf_after_text_object_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pDFAfterTextObjectFnDD58C4CAFunc == nil {
		pDFAfterTextObjectFnDD58C4CAFunc = x
	}
	return (*C.pdf_after_text_object_fn)(C.pdf_after_text_object_fn_dd58c4ca), nil
}

func NewPDFAfterTextObjectFnRef(ref unsafe.Pointer) *PDFAfterTextObjectFn {
	return (*PDFAfterTextObjectFn)(ref)
}

//export pDFAfterTextObjectFnDD58C4CA
func pDFAfterTextObjectFnDD58C4CA(cctx *C.fz_context, copaque unsafe.Pointer, cdoc *C.pdf_document, cchain *C.pdf_processor, cctm *C.fz_matrix) {
	if pDFAfterTextObjectFnDD58C4CAFunc != nil {
		ctxdd58c4ca := NewFzContextRef(unsafe.Pointer(cctx))
		opaquedd58c4ca := (unsafe.Pointer)(unsafe.Pointer(copaque))
		var docdd58c4ca []PDFDocument
		packSPDFDocument(docdd58c4ca, cdoc)
		var chaindd58c4ca []PDFProcessor
		packSPDFProcessor(chaindd58c4ca, cchain)
		var ctmdd58c4ca []FzMatrix
		packSFzMatrix(ctmdd58c4ca, cctm)
		pDFAfterTextObjectFnDD58C4CAFunc(ctxdd58c4ca, opaquedd58c4ca, docdd58c4ca, chaindd58c4ca, ctmdd58c4ca)
		return
	}
	panic("callback func has not been set (race?)")
}

var pDFAfterTextObjectFnDD58C4CAFunc PDFAfterTextObjectFn

// Ref returns a reference to C object as it is.
func (x *PDFTextState) Ref() *C.pdf_text_state {
	if x == nil {
		return nil
	}
	return (*C.pdf_text_state)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFTextState) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFTextStateRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFTextStateRef(ref unsafe.Pointer) *PDFTextState {
	return (*PDFTextState)(ref)
}

// NewPDFTextState allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFTextState() *PDFTextState {
	return (*PDFTextState)(allocPDFTextStateMemory(1))
}

// allocPDFTextStateMemory allocates memory for type C.pdf_text_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFTextStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFTextStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFTextStateValue = unsafe.Sizeof([1]C.pdf_text_state{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFTextState) PassRef() *C.pdf_text_state {
	if x == nil {
		x = (*PDFTextState)(allocPDFTextStateMemory(1))
	}
	return (*C.pdf_text_state)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFTextObjectState) Ref() *C.pdf_text_object_state {
	if x == nil {
		return nil
	}
	return (*C.pdf_text_object_state)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFTextObjectState) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFTextObjectStateRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFTextObjectStateRef(ref unsafe.Pointer) *PDFTextObjectState {
	return (*PDFTextObjectState)(ref)
}

// NewPDFTextObjectState allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFTextObjectState() *PDFTextObjectState {
	return (*PDFTextObjectState)(allocPDFTextObjectStateMemory(1))
}

// allocPDFTextObjectStateMemory allocates memory for type C.pdf_text_object_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFTextObjectStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFTextObjectStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFTextObjectStateValue = unsafe.Sizeof([1]C.pdf_text_object_state{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFTextObjectState) PassRef() *C.pdf_text_object_state {
	if x == nil {
		x = (*PDFTextObjectState)(allocPDFTextObjectStateMemory(1))
	}
	return (*C.pdf_text_object_state)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFFontDesc) Ref() *C.pdf_font_desc {
	if x == nil {
		return nil
	}
	return (*C.pdf_font_desc)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFFontDesc) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFFontDescRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFFontDescRef(ref unsafe.Pointer) *PDFFontDesc {
	return (*PDFFontDesc)(ref)
}

// NewPDFFontDesc allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFFontDesc() *PDFFontDesc {
	return (*PDFFontDesc)(allocPDFFontDescMemory(1))
}

// allocPDFFontDescMemory allocates memory for type C.pdf_font_desc in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFFontDescMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFFontDescValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFFontDescValue = unsafe.Sizeof([1]C.pdf_font_desc{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFFontDesc) PassRef() *C.pdf_font_desc {
	if x == nil {
		x = (*PDFFontDesc)(allocPDFFontDescMemory(1))
	}
	return (*C.pdf_font_desc)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFHmtx) Ref() *C.pdf_hmtx {
	if x == nil {
		return nil
	}
	return (*C.pdf_hmtx)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFHmtx) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFHmtxRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFHmtxRef(ref unsafe.Pointer) *PDFHmtx {
	return (*PDFHmtx)(ref)
}

// NewPDFHmtx allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFHmtx() *PDFHmtx {
	return (*PDFHmtx)(allocPDFHmtxMemory(1))
}

// allocPDFHmtxMemory allocates memory for type C.pdf_hmtx in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFHmtxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFHmtxValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFHmtxValue = unsafe.Sizeof([1]C.pdf_hmtx{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFHmtx) PassRef() *C.pdf_hmtx {
	if x == nil {
		x = (*PDFHmtx)(allocPDFHmtxMemory(1))
	}
	return (*C.pdf_hmtx)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFVmtx) Ref() *C.pdf_vmtx {
	if x == nil {
		return nil
	}
	return (*C.pdf_vmtx)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFVmtx) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFVmtxRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFVmtxRef(ref unsafe.Pointer) *PDFVmtx {
	return (*PDFVmtx)(ref)
}

// NewPDFVmtx allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFVmtx() *PDFVmtx {
	return (*PDFVmtx)(allocPDFVmtxMemory(1))
}

// allocPDFVmtxMemory allocates memory for type C.pdf_vmtx in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFVmtxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFVmtxValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFVmtxValue = unsafe.Sizeof([1]C.pdf_vmtx{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFVmtx) PassRef() *C.pdf_vmtx {
	if x == nil {
		x = (*PDFVmtx)(allocPDFVmtxMemory(1))
	}
	return (*C.pdf_vmtx)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFCmap) Ref() *C.pdf_cmap {
	if x == nil {
		return nil
	}
	return (*C.pdf_cmap)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFCmap) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFCmapRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFCmapRef(ref unsafe.Pointer) *PDFCmap {
	return (*PDFCmap)(ref)
}

// NewPDFCmap allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFCmap() *PDFCmap {
	return (*PDFCmap)(allocPDFCmapMemory(1))
}

// allocPDFCmapMemory allocates memory for type C.pdf_cmap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFCmapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFCmapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFCmapValue = unsafe.Sizeof([1]C.pdf_cmap{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFCmap) PassRef() *C.pdf_cmap {
	if x == nil {
		x = (*PDFCmap)(allocPDFCmapMemory(1))
	}
	return (*C.pdf_cmap)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFRange) Ref() *C.pdf_range {
	if x == nil {
		return nil
	}
	return (*C.pdf_range)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFRange) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFRangeRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFRangeRef(ref unsafe.Pointer) *PDFRange {
	return (*PDFRange)(ref)
}

// NewPDFRange allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFRange() *PDFRange {
	return (*PDFRange)(allocPDFRangeMemory(1))
}

// allocPDFRangeMemory allocates memory for type C.pdf_range in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFRangeValue = unsafe.Sizeof([1]C.pdf_range{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFRange) PassRef() *C.pdf_range {
	if x == nil {
		x = (*PDFRange)(allocPDFRangeMemory(1))
	}
	return (*C.pdf_range)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFXrange) Ref() *C.pdf_xrange {
	if x == nil {
		return nil
	}
	return (*C.pdf_xrange)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFXrange) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFXrangeRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFXrangeRef(ref unsafe.Pointer) *PDFXrange {
	return (*PDFXrange)(ref)
}

// NewPDFXrange allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFXrange() *PDFXrange {
	return (*PDFXrange)(allocPDFXrangeMemory(1))
}

// allocPDFXrangeMemory allocates memory for type C.pdf_xrange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFXrangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFXrangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFXrangeValue = unsafe.Sizeof([1]C.pdf_xrange{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFXrange) PassRef() *C.pdf_xrange {
	if x == nil {
		x = (*PDFXrange)(allocPDFXrangeMemory(1))
	}
	return (*C.pdf_xrange)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFMrange) Ref() *C.pdf_mrange {
	if x == nil {
		return nil
	}
	return (*C.pdf_mrange)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFMrange) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFMrangeRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFMrangeRef(ref unsafe.Pointer) *PDFMrange {
	return (*PDFMrange)(ref)
}

// NewPDFMrange allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFMrange() *PDFMrange {
	return (*PDFMrange)(allocPDFMrangeMemory(1))
}

// allocPDFMrangeMemory allocates memory for type C.pdf_mrange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFMrangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFMrangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFMrangeValue = unsafe.Sizeof([1]C.pdf_mrange{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFMrange) PassRef() *C.pdf_mrange {
	if x == nil {
		x = (*PDFMrange)(allocPDFMrangeMemory(1))
	}
	return (*C.pdf_mrange)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFFunction) Ref() *C.pdf_function {
	if x == nil {
		return nil
	}
	return (*C.pdf_function)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFFunction) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFFunctionRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFFunctionRef(ref unsafe.Pointer) *PDFFunction {
	return (*PDFFunction)(ref)
}

// NewPDFFunction allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFFunction() *PDFFunction {
	return (*PDFFunction)(allocPDFFunctionMemory(1))
}

// allocPDFFunctionMemory allocates memory for type C.pdf_function in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFFunctionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFFunctionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFFunctionValue = unsafe.Sizeof([1]C.pdf_function{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFFunction) PassRef() *C.pdf_function {
	if x == nil {
		x = (*PDFFunction)(allocPDFFunctionMemory(1))
	}
	return (*C.pdf_function)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFPattern) Ref() *C.pdf_pattern {
	if x == nil {
		return nil
	}
	return (*C.pdf_pattern)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFPattern) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFPatternRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFPatternRef(ref unsafe.Pointer) *PDFPattern {
	return (*PDFPattern)(ref)
}

// NewPDFPattern allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFPattern() *PDFPattern {
	return (*PDFPattern)(allocPDFPatternMemory(1))
}

// allocPDFPatternMemory allocates memory for type C.pdf_pattern in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFPatternMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFPatternValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFPatternValue = unsafe.Sizeof([1]C.pdf_pattern{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFPattern) PassRef() *C.pdf_pattern {
	if x == nil {
		x = (*PDFPattern)(allocPDFPatternMemory(1))
	}
	return (*C.pdf_pattern)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFXobject) Ref() *C.pdf_xobject {
	if x == nil {
		return nil
	}
	return (*C.pdf_xobject)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFXobject) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFXobjectRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFXobjectRef(ref unsafe.Pointer) *PDFXobject {
	return (*PDFXobject)(ref)
}

// NewPDFXobject allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFXobject() *PDFXobject {
	return (*PDFXobject)(allocPDFXobjectMemory(1))
}

// allocPDFXobjectMemory allocates memory for type C.pdf_xobject in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFXobjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFXobjectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFXobjectValue = unsafe.Sizeof([1]C.pdf_xobject{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFXobject) PassRef() *C.pdf_xobject {
	if x == nil {
		x = (*PDFXobject)(allocPDFXobjectMemory(1))
	}
	return (*C.pdf_xobject)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFDaInfo) Ref() *C.pdf_da_info {
	if x == nil {
		return nil
	}
	return (*C.pdf_da_info)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFDaInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFDaInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFDaInfoRef(ref unsafe.Pointer) *PDFDaInfo {
	return (*PDFDaInfo)(ref)
}

// NewPDFDaInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFDaInfo() *PDFDaInfo {
	return (*PDFDaInfo)(allocPDFDaInfoMemory(1))
}

// allocPDFDaInfoMemory allocates memory for type C.pdf_da_info in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFDaInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFDaInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFDaInfoValue = unsafe.Sizeof([1]C.pdf_da_info{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFDaInfo) PassRef() *C.pdf_da_info {
	if x == nil {
		x = (*PDFDaInfo)(allocPDFDaInfoMemory(1))
	}
	return (*C.pdf_da_info)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFUiEvent) Ref() *C.pdf_ui_event {
	if x == nil {
		return nil
	}
	return (*C.pdf_ui_event)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFUiEvent) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFUiEventRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFUiEventRef(ref unsafe.Pointer) *PDFUiEvent {
	return (*PDFUiEvent)(ref)
}

// NewPDFUiEvent allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFUiEvent() *PDFUiEvent {
	return (*PDFUiEvent)(allocPDFUiEventMemory(1))
}

// allocPDFUiEventMemory allocates memory for type C.pdf_ui_event in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFUiEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFUiEventValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFUiEventValue = unsafe.Sizeof([1]C.pdf_ui_event{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFUiEvent) PassRef() *C.pdf_ui_event {
	if x == nil {
		x = (*PDFUiEvent)(allocPDFUiEventMemory(1))
	}
	return (*C.pdf_ui_event)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFAlertEvent) Ref() *C.pdf_alert_event {
	if x == nil {
		return nil
	}
	return (*C.pdf_alert_event)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFAlertEvent) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFAlertEventRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFAlertEventRef(ref unsafe.Pointer) *PDFAlertEvent {
	return (*PDFAlertEvent)(ref)
}

// NewPDFAlertEvent allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFAlertEvent() *PDFAlertEvent {
	return (*PDFAlertEvent)(allocPDFAlertEventMemory(1))
}

// allocPDFAlertEventMemory allocates memory for type C.pdf_alert_event in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFAlertEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFAlertEventValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFAlertEventValue = unsafe.Sizeof([1]C.pdf_alert_event{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFAlertEvent) PassRef() *C.pdf_alert_event {
	if x == nil {
		x = (*PDFAlertEvent)(allocPDFAlertEventMemory(1))
	}
	return (*C.pdf_alert_event)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFSubmitEvent) Ref() *C.pdf_submit_event {
	if x == nil {
		return nil
	}
	return (*C.pdf_submit_event)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFSubmitEvent) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFSubmitEventRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFSubmitEventRef(ref unsafe.Pointer) *PDFSubmitEvent {
	return (*PDFSubmitEvent)(ref)
}

// NewPDFSubmitEvent allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFSubmitEvent() *PDFSubmitEvent {
	return (*PDFSubmitEvent)(allocPDFSubmitEventMemory(1))
}

// allocPDFSubmitEventMemory allocates memory for type C.pdf_submit_event in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFSubmitEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFSubmitEventValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFSubmitEventValue = unsafe.Sizeof([1]C.pdf_submit_event{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFSubmitEvent) PassRef() *C.pdf_submit_event {
	if x == nil {
		x = (*PDFSubmitEvent)(allocPDFSubmitEventMemory(1))
	}
	return (*C.pdf_submit_event)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFLaunchUrlEvent) Ref() *C.pdf_launch_url_event {
	if x == nil {
		return nil
	}
	return (*C.pdf_launch_url_event)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFLaunchUrlEvent) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFLaunchUrlEventRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFLaunchUrlEventRef(ref unsafe.Pointer) *PDFLaunchUrlEvent {
	return (*PDFLaunchUrlEvent)(ref)
}

// NewPDFLaunchUrlEvent allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFLaunchUrlEvent() *PDFLaunchUrlEvent {
	return (*PDFLaunchUrlEvent)(allocPDFLaunchUrlEventMemory(1))
}

// allocPDFLaunchUrlEventMemory allocates memory for type C.pdf_launch_url_event in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFLaunchUrlEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFLaunchUrlEventValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFLaunchUrlEventValue = unsafe.Sizeof([1]C.pdf_launch_url_event{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFLaunchUrlEvent) PassRef() *C.pdf_launch_url_event {
	if x == nil {
		x = (*PDFLaunchUrlEvent)(allocPDFLaunchUrlEventMemory(1))
	}
	return (*C.pdf_launch_url_event)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFMailDocEvent) Ref() *C.pdf_mail_doc_event {
	if x == nil {
		return nil
	}
	return (*C.pdf_mail_doc_event)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFMailDocEvent) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFMailDocEventRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFMailDocEventRef(ref unsafe.Pointer) *PDFMailDocEvent {
	return (*PDFMailDocEvent)(ref)
}

// NewPDFMailDocEvent allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFMailDocEvent() *PDFMailDocEvent {
	return (*PDFMailDocEvent)(allocPDFMailDocEventMemory(1))
}

// allocPDFMailDocEventMemory allocates memory for type C.pdf_mail_doc_event in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFMailDocEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFMailDocEventValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFMailDocEventValue = unsafe.Sizeof([1]C.pdf_mail_doc_event{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFMailDocEvent) PassRef() *C.pdf_mail_doc_event {
	if x == nil {
		x = (*PDFMailDocEvent)(allocPDFMailDocEventMemory(1))
	}
	return (*C.pdf_mail_doc_event)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PDFJsEvent) Ref() *C.pdf_js_event {
	if x == nil {
		return nil
	}
	return (*C.pdf_js_event)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PDFJsEvent) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPDFJsEventRef converts the C object reference into a raw struct reference without wrapping.
func NewPDFJsEventRef(ref unsafe.Pointer) *PDFJsEvent {
	return (*PDFJsEvent)(ref)
}

// NewPDFJsEvent allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPDFJsEvent() *PDFJsEvent {
	return (*PDFJsEvent)(allocPDFJsEventMemory(1))
}

// allocPDFJsEventMemory allocates memory for type C.pdf_js_event in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDFJsEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDFJsEventValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPDFJsEventValue = unsafe.Sizeof([1]C.pdf_js_event{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PDFJsEvent) PassRef() *C.pdf_js_event {
	if x == nil {
		x = (*PDFJsEvent)(allocPDFJsEventMemory(1))
	}
	return (*C.pdf_js_event)(unsafe.Pointer(x))
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

// unpackPUcharString represents the data from Go string as *C.uchar and avoids copying.
func unpackPUcharString(str string) (*C.uchar, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.uchar)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

// allocPUcharMemory allocates memory for type *C.uchar in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUcharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUcharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPUcharValue = unsafe.Sizeof([1]*C.uchar{})

// unpackArgSSByte transforms a sliced Go data structure into plain C format.
func unpackArgSSByte(x [][]byte) (unpacked **C.uchar, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.uchar) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPUcharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.uchar)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uchar)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.uchar)(unsafe.Pointer(h.Data))
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.uchar) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.uchar)(unsafe.Pointer(ptr0)))[i0]
		hxf2f888b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf2f888b.Data = uintptr(unsafe.Pointer(ptr1))
		hxf2f888b.Cap = 0x7fffffff
		// hxf2f888b.Len = ?
	}
}

// unpackArgSFzPixmap transforms a sliced Go data structure into plain C format.
func unpackArgSFzPixmap(x []FzPixmap) (unpacked *C.fz_pixmap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_pixmap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFzPixmapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_pixmap)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_pixmap)(unsafe.Pointer(h.Data))
	return
}

// allocPFzColorspaceMemory allocates memory for type *C.fz_colorspace in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPFzColorspaceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPFzColorspaceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPFzColorspaceValue = unsafe.Sizeof([1]*C.fz_colorspace{})

// unpackArgSSFzColorspace transforms a sliced Go data structure into plain C format.
func unpackArgSSFzColorspace(x [][]FzColorspace) (unpacked **C.fz_colorspace, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.fz_colorspace) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPFzColorspaceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.fz_colorspace)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.fz_colorspace)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.fz_colorspace)(unsafe.Pointer(h.Data))
	return
}

// packSSFzColorspace reads sliced Go data structure out from plain C format.
func packSSFzColorspace(v [][]FzColorspace, ptr0 **C.fz_colorspace) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.fz_colorspace)(unsafe.Pointer(ptr0)))[i0]
		hxfe53d34 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfe53d34.Data = uintptr(unsafe.Pointer(ptr1))
		hxfe53d34.Cap = 0x7fffffff
		// hxfe53d34.Len = ?
	}
}

// allocPFzFontMemory allocates memory for type *C.fz_font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPFzFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPFzFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPFzFontValue = unsafe.Sizeof([1]*C.fz_font{})

// unpackArgSSFzFont transforms a sliced Go data structure into plain C format.
func unpackArgSSFzFont(x [][]FzFont) (unpacked **C.fz_font, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.fz_font) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPFzFontMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.fz_font)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.fz_font)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.fz_font)(unsafe.Pointer(h.Data))
	return
}

// packSSFzFont reads sliced Go data structure out from plain C format.
func packSSFzFont(v [][]FzFont, ptr0 **C.fz_font) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.fz_font)(unsafe.Pointer(ptr0)))[i0]
		hxf685469 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf685469.Data = uintptr(unsafe.Pointer(ptr1))
		hxf685469.Cap = 0x7fffffff
		// hxf685469.Len = ?
	}
}

// allocPFzPixmapMemory allocates memory for type *C.fz_pixmap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPFzPixmapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPFzPixmapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPFzPixmapValue = unsafe.Sizeof([1]*C.fz_pixmap{})

// unpackArgSSFzPixmap transforms a sliced Go data structure into plain C format.
func unpackArgSSFzPixmap(x [][]FzPixmap) (unpacked **C.fz_pixmap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.fz_pixmap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPFzPixmapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.fz_pixmap)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocFzPixmapMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: uintptr(mem1),
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.fz_pixmap)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.fz_pixmap)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.fz_pixmap)(unsafe.Pointer(h.Data))
	return
}

// packSSFzPixmap reads sliced Go data structure out from plain C format.
func packSSFzPixmap(v [][]FzPixmap, ptr0 **C.fz_pixmap) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.fz_pixmap)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfFzPixmapValue]C.fz_pixmap)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewFzPixmapRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// allocPPDFObjMemory allocates memory for type *C.pdf_obj in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPPDFObjMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPPDFObjValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPPDFObjValue = unsafe.Sizeof([1]*C.pdf_obj{})

// unpackArgSSPDFObj transforms a sliced Go data structure into plain C format.
func unpackArgSSPDFObj(x [][]PDFObj) (unpacked **C.pdf_obj, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.pdf_obj) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPPDFObjMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.pdf_obj)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.pdf_obj)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.pdf_obj)(unsafe.Pointer(h.Data))
	return
}

// packSSPDFObj reads sliced Go data structure out from plain C format.
func packSSPDFObj(v [][]PDFObj, ptr0 **C.pdf_obj) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.pdf_obj)(unsafe.Pointer(ptr0)))[i0]
		hxf03a9a7 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf03a9a7.Data = uintptr(unsafe.Pointer(ptr1))
		hxf03a9a7.Cap = 0x7fffffff
		// hxf03a9a7.Len = ?
	}
}

// allocPFzBufferMemory allocates memory for type *C.fz_buffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPFzBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPFzBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPFzBufferValue = unsafe.Sizeof([1]*C.fz_buffer{})

// unpackArgSSFzBuffer transforms a sliced Go data structure into plain C format.
func unpackArgSSFzBuffer(x [][]FzBuffer) (unpacked **C.fz_buffer, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.fz_buffer) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPFzBufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.fz_buffer)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.fz_buffer)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.fz_buffer)(unsafe.Pointer(h.Data))
	return
}

// packSSFzBuffer reads sliced Go data structure out from plain C format.
func packSSFzBuffer(v [][]FzBuffer, ptr0 **C.fz_buffer) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.fz_buffer)(unsafe.Pointer(ptr0)))[i0]
		hxf09ea94 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf09ea94.Data = uintptr(unsafe.Pointer(ptr1))
		hxf09ea94.Cap = 0x7fffffff
		// hxf09ea94.Len = ?
	}
}
